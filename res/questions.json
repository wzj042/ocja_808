{"questions":[{"questionType":0,"questionContent":"class Equal{\n    public static void main(String[] erge){\n        String str1= \"Java\";\n        String[] str2= {\"J\",\"a\",\"v\",\"a\"};\n        String str3 = \"\";\n        for(String str : str2) \n            str3= str3+str;\n        boolean b1 =(str1==str3);\n        boolean b2 = (str1.equals(str3));\n        System.out.println(b1+\",\"+b2);\n    }\n}\n","questionTitle":"结果是什么?","options":["false,false","true,false","true,true","false,true"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n该题考的是字符串equal和==的区别，其中equal是比较值，==是比较内存地址。因为字符串不同对象的内存地址不同，即使他们值一样用==也往往无法得到预期结果，所以这里结果为false,true D"},{"questionType":0,"questionContent":"\npublic class Test {\n    public static void main(String[] args) {\n        float var1 = (12_345.01 >= 123_45.00) ? 12_456 : 124_56.02f ; \n        float var2 = var1+1024;\n        System.out.print(var2);\n    }\n}\n","questionTitle":"结果是什么?","options":["13480.0","13480.02","编译失败","在运行时引发异常错误"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考核数值中_的使用，_在数值中仅用于划分数值不会影响原本值，故var1结果为12456\n两个浮点数相加所以结果为12456.0+1024.0 = 13480.0选A"},{"questionType":1,"questionContent":"//","questionTitle":"请问关于main()方法正确的是哪项?","options":["它是一个final方法","必须定义为public类","如果在运行时执行成功，那么将会返回true","会被JRE调用"],"answers":[1,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain方法因为需要被jvm在外部调用所以访问权限需要为public，而java代码执行是通过jvm虚拟机找到main方法调用。而jvm虚拟机被jre java运行环境包含，所以说是会被jre调用也算正确\n"},{"questionType":1,"questionContent":"ArreyList<Vehicle> myList = new ArrayList<>();\nmyList.add (new MotorCycle());","questionTitle":"如果哪两项描述成立(符合其中任何一项)， 代码即可通过编译?","options":["Vehicle 和MotorCycle均继承Transportation超类(父类)","Vehicle 和MotorCycle均实现Transportation接口","MotorCycle是实现Vehicle 类的接口","Vehicle 是MotorCycle类实现的接口","MotorCycle是Vehicle 的超类(父类)","Vehicle 是MotorCycle 的超类(父类)"],"answers":[3,5],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n选择Vehicle是MotorCycle的父类则满足多态性，所以F是正确的，而 Vehicle 是MotorCycle类实现的接口.因为MotorCycle已经实现了Vehicle接口，所以作为Vechicle接口列表的myList可以成功存放MotorCycle的实例，故D也正确"},{"questionType":0,"questionContent":"public class Test {\n\tpublic static void main(String[] args){\n\t\t\tint x=5;\n\t\t\twhile(isAvailable(x)){\n\t\t\t\t// line1\n\t\t\t\tSystem .out.print(x);\n\t\t\t\t// line2\n\t\t\t}\n\t\t}\n\t\tpublic static boolean isAvailable(int x){\n\t\t\t//line3\n\t\t\treturn x-- > 0 ? true : false;\n\t\t}\n}","questionTitle":"哪项修改可使该代码输出54321?","options":["将第line1行注释语句替换为System.out.print(--x);","将第line3行注释语句替换为return (x>0) ? false:true;","在第line2行插入x--;","将第 line1行注释语句替换为--x; 并在line2行插入System.out.print(x);"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处考的是方法传递参数的值传递和引用传递，这里isAvailable方法传入的x因为是基本类型所以只会复制一份值传入，修改其中的值不会改变原始的变量。所以这里会一直返回true造成死循环。所以需要在循环内为变量做自减操作以保证循环可终止，故选C"},{"questionType":0,"questionContent":"public class Test {\n\tpublic static void main(String[] args) {\n\t\tchar colorCode = 'y';\n\t\tswitch (colorCode) {\n\t\t\tcase 'r':\n\t\t\t\t// line1\n\t\t\t\tint color = 100;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\t// line2\n\t\t\t\tcolor = 10;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\t// line3\n\t\t\t\tcolor = 1;\n\t\t\t\tbreak;\n\t\t}\n\t\t// line4\n\t\tSystem.out.println(color);\n\t}\n}","questionTitle":"请问结果是什么? ","options":["在line1行出现编译错误.","在line4行出现编译错误","在line2和line3行出现编译错误","打印出:1"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处考的是变量的作用域，大括号{}内被视作一个作用域，作用域只能调用外部的但不能调用内部.即此处line4行的color因为调用了switch语句内作用域定义的变量color而会出现编译错误所以选B"},{"questionType":0,"questionContent":"\npublic class App {\n\tint foo;\n\tstatic int bar;\n\tstatic void process() (\n\t\tfoo += 10;\n\t\tbar += 10;\n\t}\n\tpublic static void main(String[] args){\n\t\tApp firstObj = new App(); \n\t\tApp.process();\n\t\tSystem.out .println(firstObj .bar);\n\t\tApp secondObj = new App ();\n\t\tApp.process();\n\t\tSystem. out .println (secondObj.bar);\n\t}\n}\n","questionTitle":"请问结果是什么? ","options":["编译时出现错误","10\n10","10\n20","20\n20"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n静态方法只能调用静态变量，此处process方法调用非静态变量foo所以会编译错误，故选A"},{"questionType":0,"questionContent":"class LogFileException extends Exception{}\nclass AccessViolationException extends  RuntimeException{}\n\npublic class App {\n\t// line1\n\tpublic static void main(String[] args) throws LogFileException {\n\t\tApp obj = new App();\n\t\ttry{\n\t\t\t\n\t\t\t// line2\n\t\t\t//代码插入在这里\n\t\t}\n\t\tcatch(Exception e){\n\t\t\t\tSystem. out.println(\"Completed.\");\n\t\t}\n\t}\n\t// line3\n\tpublic void process() {\n\t\tSystem. out .println(\"Processed\");\n\t\tthrow new LogFileException();\n\t}\n\t// line4\n\tpublic void open(){\n\t\tSystem.out.println(\"Opened.\");\n\t\tthrow new AccessViolationException ();\n\t}\n}\n","questionTitle":"请问下面哪项可以修正编译错误? ","options":["在line3行，插入throws LogFileException ","在line1行，将throws AccessViolationException 替换为throws LogFileException ","在line2行，插入throw new LogFileException();","在line4行插入throws AccessViolationException "],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nRuntimeException指的是运行时异常，指编译器不强制要求处理的异常，所以不需要特意捕获。此处因为process方法抛出了方法却没有使用try catch捕获或在方法上使用throws继续向上抛出所以会编译错误，选项中可取的只有A，在 方法名() 后增加throws语句将内部抛出错误继续向上抛出"},{"questionType":0,"questionContent":"class Book {\n\tint pages;\n}\n\npublic class App {\n\tint count;\n\tpublic void method(Book x, int k) {\n\t\tx.pages = 100;\n\t\tk = 200;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tApp obj = new App() ;\n\t\tBook objBook = new Book() ;\n\t\tSystem.out .println(objBook.pages +\":\"+ obj.count);\n\t\tobj .method (objBook, obj.count) ; \n\t\tSystem.out.println(objBook.pages +\":\"+ obj.count);\n\t}\n}","questionTitle":"请问结果是什么?","options":["0:0 \n100:0","null : null\n100 : null","0: 0\n100 : 200","0: 0\n200 :100"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考的是变量默认初始值和方法的两种参数传递方式。首先输出App和Book的两个没有指定值的整型变量，因为整型变量默认初始值为0，所以先输出0:0\n然后通过内置方法调用传递了一个对象引用和一个基本变量去修改值，这里方法传递时传递如数组，对象等是引用传递，即修改传递入的变量会影响原本的变量。而像整型等基本变量则只是传值进去，修改传递变量不会影响原变量。所以这里objBook.pages被修改为100,而count则没有变化。因此输出100:0,故选A"},{"questionType":0,"questionContent":"import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tList<String> lst = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\t\tIterator<String> itr = lst.iterator();\n\t\twhile (itr.hasNext()) {\n\t\t\tString e = itr.next();\n\t\t\tif (e == \"C\") {\n\t\t\t\tbreak;// line1\n\t\t\t} else {// line2\n\t\t\t\tcontinue;// line3\n\t\t\t\tSystem.out.print(e);// line4\n\t\t\t}// line5\n\t\t}\n\t}\n}","questionTitle":"请问哪项可以打印出AB?","options":["注释掉line3","注释掉line2","注释掉line1","注释掉line2到line5"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处是将数组转换为list之后遍历，题目要求是输出AB，则原本代码执行逻辑应该为判断为C则中断循环，遍历到其他字符则进行判断，这里line3处是直接跳到下一个循环，使后面line4的输出语句直接执行不到，会造成编译错误。也无法输出AB，所以只要注释掉continue即line3就可以输出AB，故选A"},{"questionType":0,"questionContent":"\npublic class Test {\n\tpublic static void main(String[] args){\n\t\t\tString ta = \"A\";\n\t\t\tta = ta.concat(\"B\");\n\t\t\tString tb = \"C\";\n\t\t\tta = ta.concat(tb);\n\t\t\tta.replace(\"C\",\"D\");\n\t\t\tta = ta.concat(tb);\n\t\t\tSystem.out.println(ta);\n\t\t}\n}","questionTitle":"结果是什么?","options":["A B C D","A C D","A B C C","A B D","A B D C"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n简单的字符串api考察，只使用了拼接字符串和替换字符串，但是这里替换后的字符串没有赋值给原字符串所以replace这一行语句实际不会有结果，所以输出为ABCC选C"},{"questionType":0,"questionContent":"\npublic class Test {\n\tpublic static void main(String[] args){\n\t\tString shirts[][] = new String[2][2];\n\t\tshirts[0][0]=\"red\";\n\t\tshirts[0][1]=\"blue\";\n\t\tshirts[1][0]=\"small\";\n\t\tshirts[1][1]=\"medium\";\n\t}\n}","questionTitle":"哪个代码片段能遍历shirts数组输出\nred:blue: small:medium:?","options":["for (int index = 0;index < 2; ++index) {\n\t\t\tfor (int idx=0; idx < index; ++idx) {\n\t\t\t\tSystem.out.print (shirts[index][idx] + \":\");\n\t\t\t}\n\t\t}","for (int index = 0;index < 2; ) {\n\t\t\tfor (int idx=0; idx < 2; ) {\n\t\t\t\tSystem.out.print (shirts[index][idx] + \":\");\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tindex++;\n\t\t"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察遍历二维数组，A选项内层循环的终止条件是小于上一层的索引，无法遍历完二维数组。所以选B"},{"questionType":0,"questionContent":"import java.util.Arrays;\nimport java.util.List;\n\npublic class Test {\n\tpublic static void main(String[] args){\n\t\tList<String> lst = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\t\t/* insert code here */\n\t\t\n\t}\n}","questionTitle":"插入哪个代码段可以打印出DCBA?","options":["\t\tint idx = 0;\n\t\twhile(idx>=0){\n\t\t\tidx = lst.size();\n\t\t\tSystem.out.print(lst.get(--idx));\n\t\t}","int idx = lst.size()-1;\n\t\twhile(idx>=1){\n\t\t\tSystem.out.print(lst.get(idx));\n\t\t\tidx--;\n\t\t}","int idx = lst.size();\n\t\t while(idx>=1){\n\t\t\t System.out.print(lst.get(--idx));\n\t\t }","int idx = lst.size();\n\t\twhile(idx>0){\n\t\t\tSystem.out.print(lst.get(idx--));\n\t\t}"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项循环内给循环条件赋值为固定值，只会死循环\nB选项终止循环条件是idx=1，此时输出不到第一项\n\nC选项 变量--先执行算术操作再返回变量，循环条件结束idx为1时可以正常自减为0获取第一个元素所以正确\n\nD选项 --变量是先返回值再执行算术操作，所以第一次循环会先从列表大小值获取元素发生越界错误，改成变量--可以正确输出"},{"questionType":1,"questionContent":"// ","questionTitle":"下面哪两个初始化语句是正确的?","options":["String tmpAuthor = author, author = Mo Donald","Double price = 200D;","Integer pages = 20;","Boolean available = TRUE;"],"answers":[1,2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项 即使是变量赋值也在后面才定义所以会报引用错误，而且最后没有加引号和分号\n\nB选项 双精度浮点数后缀加大小写d都是正确的\n\nC选项 int的包装类Integer，可以正常赋值，赋值的过程被称作自动装箱\n\nD选项 布尔值变量值都是小写"},{"questionType":0,"questionContent":"public class Test{\n    void readCard(int cardNo) throws Exception{\n        System.out.println(\"Reading Card\");\n    }\n    void checkCard(int cardNo) throws RuntimeException{ //line n1\n        System.out.println(\"Checking Card\");\n    }\n    public static void main(String[] args){\n        Test ex = new Test();\n        int cardNo = 12344;\n        ex.checkCard(cardNo);\t\t//line n2\n        ex.readCard(cardNo);\t\t//line n3\n    }\n}","questionTitle":"结果是什么?","options":["编译仅在line n3处失败","编译仅在line n1处失败","Reading Card\nChecking Card","编译仅在line n2处失败","编译在line n2和line n3处均失败"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这是考察对错误的理解，这里checkCard抛出的RuntimeExps是非检查的运行时异常，属于运行时才能发现的通常是代码逻辑的异常，一般不用抛出，抛出了也无法处理。而Exception默认异常是用于警醒使用者代码调用处可能会发生的异常，不捕获就会编译错误。故在line n3处编译失败"},{"questionType":0,"questionContent":"public class App{\n  public static void main(String[] args){\n      int vI = 10;\n      float vF = 100.05f;\n      Long c1 = vI; // line 5\n      long c2 = vI; // line 6\n      float c3 = vF; // line 7\n      double c4 = vF; // line 8\n  }\n}","questionTitle":"请问下面哪个选项可以修正错误? ","options":["用Integer c1 = vI替换line 5;","用Long c2 = vI替换line 6:","用float e3 =vF替换line 7 :","用Double C4 = vF替换line 8 ;"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nLong类型是一个对象(注意大小写)，需要使用对象实例化或者valueOf()方法将int类型的vI转换为Long类型。因此，可以使用Integer c1 = vI或者Long c1 = Long.valueOf(vI)来使编译通过。\n\nint和long可以自动转换，但是Integer和Long是不同的基本类型的包装类，需要使用相应的构造函数或valueOf()方法来进行转换。同样的情况也适用于float和double类型的转换。"},{"questionType":0,"questionContent":"////////////Tree//////////////\npackage root;\npublic class Tree{\n    public void m1(){}\n    private void m2(){}\n    protected void m3(){}\n    void m4(){}\n}\n////////////Plant//////////////\npackage branch;\n\nimport root.*;\npublic class Plant extends Tree{\n    public void m1(){}\n    public void m2(){}\n    public void m3(){}\n    public void m4(){}\n}\n////////////Test//////////////\nimport branch.Plant;\nimport root.Tree;\n\npublic class Test{\n    public static void main(String[] args){\n        Tree t = new Plant();\n        // line 10\n    }\n}\n","questionTitle":"[存疑]假设Tree.java和Plant.java文件的内容如下：\n请问在line10 插入下面哪项是正确的?","options":["t.m1();","t.m1();\nt.m3();","t.m1();\nt.m3();\nt.m4();"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处是泛型继承，调取的是父类的方法所以除了m1都无法访问。因为m2是私有只能Tree内部类访问，m3只能同一个包内的子类内访问，m4默认访问修饰也是同一包内可访问\n\n*该题与原答案冲突"},{"questionType":0,"questionContent":"\npublic class Test{\n    public static void main(String[] args){\n        int array1[] ={1,2,3};\n        int array2[] = new int[5];\n        array2 = array1;\n        for(int i : array2){\n            System.out.print(i+\" \");\n        }\n        System.out.println();\n        int array3[] = new int[3];\n        array3 = array2;\n        for(int i : array3){\n            System.out.print(i+\" \");\n        }\n    }\n}","questionTitle":"请问结果是什么? ","options":["1 2 3 0 0\n1 2 3 0 0","运行时抛出异常（Exception）","1 2 3 0 0\n1 2 3","1 2 3\n1 2 3"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数组是引用传递，赋值不会新建数组而是将原数组引用传递，所以此处array2和array3实际上都赋值成了array1\n即输出都是1 2 3选D\n"},{"questionType":0,"questionContent":"\npublic class Test{\n    public static void main(String[] args){\n        String str = \"Sweet Sweat\";\n        String str2 = str.trim().charAt(6) + \" \" + str.indexOf(\"Sw\",1);\n        System.out.println(str2);\n    }\n}","questionTitle":"请问结果是什么?","options":["S 5\t","w 7","-1","S 6"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察字符串api使用，trim是去除首尾空格。charAt获取字符指定位置字符，此处为S，indexOf是查找字符索引，后一个参数是指定开始寻找的索引。不加则从0开始，此处从第一位开始查找即从\"weet Sweat\"查找Sw,即输出6\n答案选D S 6"},{"questionType":0,"questionContent":"\npublic class Test{\n    public static void main(String[] args){\n        String option = \"j\";\n        switch(option){\n            case \"1\":\n                System.out.print(\"A\");\n            case \"2\":\n            case \"4\":\n                System.out.print(\"B\");\n                break;\n            case \"3\":\n            case \"5\":\n                System.out.print(\"C\");\n            default:\n                System.out.print(\"E\");\n        }\n    }\n}","questionTitle":"请问结果是什么?","options":["C","CE","ABCE","E"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nemm...意义不明的考察，匹配条件全部不匹配那只能是输出默认的default下的E了"},{"questionType":1,"questionContent":"////////////////////Customer///////////////////////\npackage sales;\n\npublic class Customer {\n    public void m1(){}\n    private void m2(){}\n    protected void m3(){}\n    void m4(){}\n}\n////////////////////Trader///////////////////////\npackage market;\n\nimport sales.*;\npublic class Trader extends Customer{\n    \n}","questionTitle":"假设Customer.java 和 Trader.java文件的内容如下，下面哪两个Customer类的方法可以被Trader类覆盖?","options":["m2()","m3()","m1()","m4()"],"answers":[1,2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察访问修饰符，这里public可以给外部类公共访问所以m1可覆盖，m3是同包内继承子类可访问所以也可以覆盖。而默认不加修饰符只能同包内访问，此处两个类不在同一个包，不可以覆盖，m2是私有方法也不能覆盖。"},{"questionType":0,"questionContent":"public class Shop {\n    public static void main(String[] args) {\n        int price = 1000;\n        int qty = 2;\n        String grade = \"2\";\n        double discount = 0.0;\n        switch (grade) {\n            case \"1\":\n                discount = price * 0.1;\n                break; // line 1\n            case \"2\":\n                discount = price * 0.5;\n                continue; // line 2\n            default:\n                System.out.println(\"Thank You!\");\n        }\n        System.out.println(discount);\n    }\n}","questionTitle":"请问哪一项是正确的?","options":["程序执行并且输出：\n500.0","注释掉line 2使得程序输出：\nThank You!\n500.0","程序执行并且输出：\nThank You!\n500.0","注释掉line 1使得程序输出：\nThank You!\n500.0"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ncontinue语句用于循环中进入下一次循环，不能在单独的switch语句中使用。所以选B注释掉line2"},{"questionType":1,"questionContent":"class Employee{\n    public int salary;\n}\n\nclass Manager extends Employee{\n    public int budget;\n}\n\nclass Director extends Manager{\n    public int stockOptions;\n}\n\npublic class Test{\n\n    public static void main(String[] args){\n        Employee employee = new Employee();\n        Manager manager = new Manager();\n        Director director = new Director();\n        //line n1\n        \n    }\n\n}","questionTitle":"哪两个选项放置在main方法的line n1处会编译失败?","options":["director.stockOptions = 1_000;","manager.stockOption = 500;","director.salary = 80_000;","employee.salary  = 50_000;","manager.budget = 1_000_000;","employee.budget = 200_000;"],"answers":[1,5],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n父类无法访问到继承的子类的字段，所以B和F试图访问子类的字段都会导致编译失败"},{"questionType":0,"questionContent":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Player{}\n\ninterface Playable{\n    public void play();\n    public void setPlayers(List<Player> players);\n}\n\nclass Game implements Playable{\n    private List<Player> players;\n    public List<Player> getPlayers(){ return players; }\n    public void setPlayers(List<Player> players){ this.players = players;  }\n    public void play() { System.out.println(\"Played.\"); }\n}\npublic class Test{\n\n    public static void main(String[] args){\n        Playable p = new Game();\n        List<Player> players  = new ArrayList<>();\n        p.setPlayers(players);\n\n    }\n\n}","questionTitle":"关于上面的定义和代码段对于面向对象编程概念的应用，哪个描述是对的?","options":["应用了多态，抽象和封装","只应用了继承和封装","应用了多态，继承和抽象","只应用了多态和继承"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain中第一行使用多态将Game类使用本身实现了的Playerable接口定义，抽象则表现为interface接口中定义的两个方法，封装则是将players字段和相关方法封装在Game类中，故选A。"},{"questionType":0,"questionContent":"/*\n我不敢苟同你的观点，我觉得吃披萨应该加95号汽油\n、\n*/","questionTitle":"关于Java字节代码，哪项描述是正确的?","options":["它可以在具有Java运行时环境的任何平台上运行。","它可以在具有Java编译器的任何平台上运行。","它可以在任何平台上运行。","它只能在编译时指定平台上运行。","它只能在具有Java运行时环境和Java编译器的平台上运行"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\njava字节码指java文件编译后的class文件，因为是编译后文件所以编译器不是必须的，但想要运行class文件需要具有java运行时环境JRE以执行字节码文件，故A描述符合"},{"questionType":0,"questionContent":"class P1{}\nclass P2 extends P1 implements I1{}\ninterface I1{}\n\n\npublic class Test{\n\n    public static void main(String[] args){\n        P1 obj = new P1();\n        P2 obj2 = new P2();\n        I1 obj3 = new P2();\n        boolean r1 = obj instanceof P2;\n        boolean r2 = obj2 instanceof P1;\n        boolean r3 = obj3 instanceof I1;\n        System.out.println(r1 + \":\" + r2 + \":\" + r3);\n\n    }\n\n}","questionTitle":"关于Java字节代码，哪项描述是正确的?","options":["true:false:true","false:true:true","true:true:false","false:true:false"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ninstanceof判断对象是否实例化于指定类型，此处r1通过P1实例化，跟作为自身子类的P2进行实例化判断会返回false，而实现了接口的类根据多态的原则是可以通过接口实例化的所以r3也是true，所以选B"},{"questionType":0,"questionContent":"public class Game{\n    public static void menu(){\n        System.out.println(\"1.Left \\n2. Right \\n0. Stop\");\n    }\n    public static void main(String[] args){\n        int option;\n        /* insert code here */\n        \n    }\n}","questionTitle":"应用程序需求如下：\n1.菜单（menu）必须被显示\n2.被选择的选项必须被打印\n3.直到读到 '0' ，否则必须循环执行\n下面的代码段满足需求的是哪个?","options":["for (option = 0; option != 0; \n             option =  /* code that reads the option goes here */){\n            /* code that print the option go here  */\n        }","do{\n            menu();\n            option = //code that reads the option goes here\n            /* code that print the option go here*/\n        }while(option != 0);","while (option >= 0 ){\nmenu();\noption = //code that reads the option goes here\n/* code that print the option go here*/\n}","while(option != 0){\nmenu();\noption = //code that reads the option goes here\n/* code that print the option go here*/\n}"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项比并没有调用menu方法可以直接排除，而且for初始条件为0，读取在判断非0后，没有循环的条件。B选项是先执行后循环，所以必定显示菜单，其余代码也符合条件故正确。C选项因为没有初始值所以需要循环判断等于0，但因此输入0时还会继续运行不满足第三点，D选项没有定义相应初始值无法进行循环。"},{"questionType":0,"questionContent":"interface Downloadable{\n    public void download();\n}\n\n\ninterface Readable extends Downloadable{\t//line n1\n    public void readBook();\n}\n\nabstract class Book implements Readable{\t//line n2\n    public void readBook(){\n        System.out.println(\"Read Book\");\n    }\n}\n\nclass EBook extends Book{\t\t\t//line n3\n    public void readBook(){\n        System.out.println(\"Read E-Book\");\n    }\n}\npublic class Test{\n\n    public static void main(String[] args){\n        Book book1 = new EBook();\n        book1.readBook();\n\n    }\n\n}","questionTitle":"结果是什么?","options":["Read Book","编译在line n1处失败","编译在line n3处失败","编译在line n2 处失败","Read E-Book"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n抽象类实现接口可以不实现方法，但具体类EBook继承层级中包含的接口方法都应该被实现，此处line n3处EBook未实现Downloadable中的抽象方法所以会编译失败"},{"questionType":0,"questionContent":"public class App{\n    String greet = \"Welcome!\";\n    public App(){\n        String greet = \"Hello!\";\n    }\n\n    public void setGreet(){\n        String greet = \"Good Day!\";\n    }\n    public static void main(String[] args){\n        App t = new App();\n        String greet = \"Good Luck!\";\n        System.out.println(t.greet);\n    }\n}","questionTitle":"结果是什么?","options":["Hello!","Good Luck!","Good Day!","Welcome!"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这里是实例化类之后调用greet，默认会调取成员变量，又因为构造函数中只是新建了同名的局部变量所以不会影响本身的成员变量，因此输出的只是默认的Welocome"},{"questionType":1,"questionContent":"public class Shape{\n    int m;\n    int l;\n    //line n1\n\n    public Shape(){\n        this.l = 100;\n        this.m = 100;\n    }\n    public Shape(int l, int m){\n        this.l = l;\n        this.m = m;\n    }\n    public void print(){\n        System.out.print(l+\" : \"+m);\n    }\n    public static void main(String[] args){\n        Shape sh = new Shape(1000);\n        sh.print();\n    }\n}","questionTitle":"请问下面在line n1处增加哪个构造器定义可以打印出100 ： 1000?","options":[")public Shape(int m){\n\tthis();\n\tthis.l = 100;\n\tthis.m = m\n\t}","public Shape(int m){\n\tthis.m = m;\n\tthis(100,this.m);\n\t}","public Shape(int m){\n\tthis(100,m);\n\t}","public Shape(int m){\n\tthis.l = 100;\n\tthis(this.l,this.m);\n\t}"],"answers":[0,2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA是增加一个构造方法以适应main中的错误构建实例，故正确，B中看似正确，但是this方法应该放在构造方法首行所以是错误的，并且即使this换到第一行也不应在其中使用后续定义的this.m，C是新建构造方法并且通过硬编码的方式为l赋值，输出的结果是符合的所以正确。D选项和B是同样的错误不重复赘述"},{"questionType":0,"questionContent":"\nclass A {\n\tstatic int hitCount;\n\n\tstatic void printHitCount() {\n\t\tSystem.out.println(\"A class \" + hitCount);\n\t}\n}\n\nclass B extends A {\n\tstatic void printHitCount() {\n\t\tSystem.out.println(\"B class \" + hitCount);\n\t}\n}\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\tA.hitCount = 100;\n\t\tB.hitCount = 200;\n\t\tA.printHitCount();\n\t\tB.printHitCount();\n\t}\n\n}","questionTitle":"请问结果是什么?","options":["A class 100\nA class 200","B class 200\nB class 200","A class 100\nB class 200","A class 200\nB class 200"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nB继承A且未单独新定义同名字段，故两个静态类调用同一个变量，所以最后都是赋值成200，输出则是调用各自定义的静态方法，所以选D"},{"questionType":1,"questionContent":"\npublic class Test{\n\n    public static void main(String[] args){\n        double discount = 0;\n        int qty = Integer.parseInt(args[0]);\n        //line n1;\n        \n    }\n\n}","questionTitle":"如果qty变量的值大于或等于90，则discount = 0.5\n  如果qty变量的值介于80和90之间，则discount=0.2\n在line n1处单独放入哪两个代码片段可满足这些需求?","options":["discount = (qty > 80) ? 0.2 : (qty >= 90) ? 0.5 : 0;","discount = (qty >= 90) ? 0.5 : (qty > 80) ? 0.2 : 0;","if (qty > 80 && qty <90){\n\t\tdiscount = 0.2;\n\t}else{\n\t\tdiscount = 0;\n\t}\n\tif (qty >= 90){\n\t\tdiscount = 0.5;\n\t}else{\n\t\tdiscount = 0;\n\t}","discount = (qty >= 90) ? 0.5 : 0;\n\tdiscount = (qty > 80) ? 0.2 : 0;","if (qty >= 90) {\n            discount = 0.5;\n        }\n        if (qty > 80 && qty < 90) {\n            discount = 0.2;\n        }"],"answers":[1,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项判断结果是大于80都是0.2，小于80则无法大于等于90只能为0。\nB选项三元表达式得到0.2条件为80<qty<90满足条件故正确。\nC选项前面满足条件，但后一个判断中else重复赋值导致前一个选项结果被覆盖因此错误。\nD选项重复判断两次但是未将条件放在一起导致最后只是判断>80则为0.2，错误。\nE选项将位于80和90之间和大于等于90的条件分开判断，但是不影响后一个if循环满足条件能得出正确值"},{"questionType":0,"questionContent":"\npublic class Test {\n\n    public static void main(String[] args) {\n        int x = 100;\n        int a = x++;\n        int b = ++x;\n        int c = x++;\n        int d = (a<b) ? (a<c) ? a : (b<c) ? b:c;\n        System.out.println(d);\n    }\n\n}","questionTitle":"假定代码片段如下，结果是什么?","options":["101","100","编译失败","103","102"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n三目表达式问号数量和冒号数量不匹配"},{"questionType":0,"questionContent":"//////////原代码\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        String[] arr = {\"Hi\", \"How\", \"Are\", \"You\"};\n        List<String> arrList = new ArrayList<>(Arrays.asList(arr));\n        if (arrList.removeIf((String a) -> {\n            return s.length() <= 2;\n        })) {\n            System.out.println(a + \"removed\");\n        }\n    }\n\n}","questionTitle":"结果是什么?","options":["Hi removed","编译失败","在运行时引发UnsupportedOperationException","该程序会通过编译,但不输出任何内容."],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n该题使用集合的removeIf方法删除变量，但是原代码意义不明，使用了lmbda表达式就不应该定义a的参数类型了，这里表达式中的是删除条件(而且此处s未定义)，理论上应该删除Hi然后返回的，但是输出语句中是获取不到lmbda定义的a的所以应该是编译失败"},{"questionType":0,"questionContent":"\nclass OraString{\n    String s;\n    public boolean equals(OraString str){\n        return this.s.equalsIgnoreCase(str.toString());\n    }\n    OraString(String s){\n        this.s = s;\n    }\n}\npublic class Test {\n\n    public static void main(String[] args) {\n        String s1 = \"Moon\";\n        OraString s2 = new OraString(\"Moon\");\n\n        if((s1==\"Moon\")&&(s2.equals(\"Moon\"))) {\n            System.out.println(\"A\");\n        }else {\n            System.out.println(\"B\");\n        }\n\n        if(s1.equalsIgnoreCase(s2.s)) {\n            System.out.println(\"C\");\n        }else {\n            System.out.println(\"D\");\n        }\n    }\n\n}","questionTitle":"结果是什么?","options":["BD","BC","AD","AC"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字符串相等判断通过equal才能判断值相等，直接==判断的是内存地址一般都不相等，所以&&判断第一个为false直接短路输出B，然后大小写忽略判断值，输出C 则最终输出BC"},{"questionType":0,"questionContent":"import java.util.ArrayList;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        ArrayList<E> myList = new ArrayList();\n        String[] myArray;\n        try {\n            while(true) {\n                myList.add(\"My String\");\n            }\n        }catch(RuntimeException re) {\n            System.out.println(\"Caught a RuntimeException\");\n        }catch(Exception e) {\n            System.out.println(\"Caught a Exception\");\n        }\n        System.out.println(\"Ready to use\");\n    }\n\n}","questionTitle":"结果是什么?","options":["在第二个catch语句终止执行,并在控制台输出Caught an Exception","在线程main中引发线程错误","正常完成执行,并在控制台输出Ready to use","该代码编译失败,因为需要throw关键字","在第一个catch语句终止执行,并在控制台输出Caught an RuntimeException"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n整不会了，确实应该编译失败因为一开始定义的E是未定义的类型，但是这里D的理由就很奇怪，还是默认D吧"},{"questionType":0,"questionContent":"\npublic class Test {\n\n    int b = 2, h=3;\n    public static void main(String[] args) {\n        double p,b,h;\n        if(area == 0) { // line n1\n            b = 3;\n            h = 4;\n            p = 0.5;\n        }\n        area = p*b*h; // line n2\n        System.out.println(\"Area is\" +area);\n\n    }\n\n}","questionTitle":"结果是什么?","options":["Area is 3.0","编译在n2处失败","Area is 6.0","编译在n1处失败"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n未声明area变量调用"},{"questionType":1,"questionContent":"// 无题干","questionTitle":"当应用了异常处理(Exception Handing)技术以后,我们可以从java程序中得到那两项功能?","options":["自动的错误日志","优化后的代码","对象之间的通信","程序执行的流程控制","错误类型"],"answers":[0,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nD选项还沾点边，BC选项就是占位了，所以选强关联的AE\n"},{"questionType":0,"questionContent":"class C2{\n    public void display2(){\n        System.out.println(\"C2\");\n    }\n}\ninterface I{\n    public void displayI();\n}\nclass C1 extends C2 implements I{\n    public void displayI(){\n        System.out.println(\"C1\");\n\n    }\n\n}\npublic class Test {\n    public static void main(String[] args) {\n       C1 c1 = new C1();\n       C2 c2 = new C2();\n       c1.displayI();\n       c2.display2();\n    }\n\n}","questionTitle":"结果是什么?","options":["编译失败","C1\nC1","C2\nC2","C1\nC2"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这题甚至没给实例代码和答案，实例是我编的，只要知道C1也可以调用C2的方法就可以了，这里C1也实现了接口方法不会编译错误。"},{"questionType":1,"questionContent":"// 无题干","questionTitle":"请问关于main方法正确的是?","options":["它是一个final方法","必须定义为public","如果在运行时执行成功,将会返回true","会被JRE调用."],"answers":[1,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain方法作为入口是没有返回值的，jre用于执行java文件确实会调用到main方法，不定义为public就无法使外部编译器调用到了，所以选BD"},{"questionType":0,"questionContent":"\npublic class Test {\n    public static void main(String[] args) {\n        boolean a = new Boolean(Boolean.valueOf(args[0]));\n        boolean b = new Boolean(args[1]);\n        System.out.println(a+\" \"+b);\n    }\n\n}","questionTitle":"假定运行以下命令\njavac Test.java\njava Test TRUE null\n结果是什么?","options":["TRUE NULL","true true","false false","在运行时抛出ClassCastException","true false"],"answers":[4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察对命令执行的理解，执行java命令时文件名后带的参数会通过args传递进程序，此处b接受null转换为布尔值为false，故输出true false选E\n\n*注意jdk9以后使用构造函数转换布尔值方法已被废弃"},{"questionType":0,"questionContent":"\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(5);\n        String s = \"\";\n        if(sb.equals(s)) {\n            System.out.println(\"Match 1\");\n        }else if(sb.toString().equals(s.toString())) {\n            System.out.println(\"Match 2\");\n        }else {\n            System.out.println(\"No Match\");\n        }\n    }\n\n}","questionTitle":"结果是什么?","options":["No Match","Match 2","运行时引发NullPointException","Match 1"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n空字符匹配，但是StringBuilder的equal默认是比较内存地址，所以匹配会失败，只有sb转换成String之后执行equals才是进行值匹配，所以返回Match 2 选B"},{"questionType":0,"questionContent":"public class MainTest{\n\n    public static void main(String[] args) {\n        System.out.println(\"int main \"+ args[0]);\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Object main\" + args[0]);\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"String main\" + args[0]);\n\n    }\n}","questionTitle":"运行以下命令\njavac MainTest.java\njava MainTest 1 2 3\n结果是什么?","options":["在运行时引发一场错误","String main 1","Object main 1","int main 1","编译失败"],"answers":[4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n同名方法重复定义声明，不重载参数只会编译失败"},{"questionType":0,"questionContent":"// ","questionTitle":"客车与船都是交通工具(Vehicle类)，方法start()和stop()是交通工具(Vehicle类)的公共方法\n方法ride()用于表示每一种交通工具(Vehicle)类的特殊方法\n下面哪个选项符合上述描述?","options":["1.创建定义了start()和stop()方法的交通工具接口,并且定义ride()抽象方法\n2.创建应用交通工具接口的客车类和船类.","B.创建了一个定义了stop()方法,start()方法的抽象类交通工具,并且拥有抽象方法ride().\n创建继承自交通工具类的客车类和船类,并且覆盖了ride()方法","C.创建一个定义了stop()方法,start()方法的抽象类交通工具,并且拥有抽象方法ride().\n创建继承自交工工具类的客车类和船类,并且覆盖所有的方法","D.创建了一个定义了默认stop()方法,start()方法的交通工具接口(interface),和一个ride()方法\n创建了应用交通工具接口的客车类和船类,并且覆盖ride()方法."],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字太多看的头疼，接口中是不能定义带有方法体的方法的，所以为了满足交通工具类的公共方法这一条件AD直接排除，然后C覆盖所有方法也不满足公共方法这一条件，所以选B"},{"questionType":1,"questionContent":"// ","questionTitle":"哪三项是java异常错误机制的优势?","options":["由于必须在发生异常错误的方法中处理异常错误,因此改进了程序结构","由于程序可以选择处理异常错误的位置,因此改进了程序结构.","允许创建新异常错误,可以针对要创建的特定程序定制异常错误","提供一组标准异常错误,涵盖所有可能的错误","由于错误处理代码与正常程序功能分离,因此改进了程序结构"],"answers":[1,2,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n不是必须在发生错误的地方处理错误，标准错误无法涵盖所有错误"},{"questionType":0,"questionContent":"public class App{\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"blue\");\n            m();\n            throw new Exception();\n        }catch(RuntimeException re) {\n            System.out.println(\"yellow\");\n        }catch(Exception e) {\n            System.out.println(\"green\");\n        }finally {\n            System.out.println(\"orange\");\n        }\n\n    }\n    public static void m() {\n        System.out.println(\"purple\");\n        throw new RuntimeException();\n    }\n}","questionTitle":"结果是什么?","options":["blue\npurple\nyellow\ngreen\norange","blue\npurple\norange","blue\ngreen\norange","blue\npurple\nyellow\norange"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nm方法先抛出错误，所以先输出blue purple，然后捕获到运行时错误输出yellow。接着程序会执行finally块跳过后续代码(抛出Exps那行)，所以选D"},{"questionType":0,"questionContent":"class Vehicle{\n    Vehicle(){\n        System.out.println(\"Vehicle\");\n    }\n}\nclass Bus extends Vehicle{\n    Bus(){\n        System.out.println(\"Bus\");\n    }\n}\npublic class Transport{\n    public static void main(String[] args) {\n        Vehicle v = new Bus();\n    }\n}","questionTitle":"结果是什么?","options":["Vehicle\nBus","B.程序不会打印任何内容","Bus","Bus\nVehicle"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n实例化子类会默认调用父类的构造函数，两个构造函数内输出都会执行。"},{"questionType":0,"questionContent":"int [] intArr = {8,16,32,64,128};","questionTitle":"单独使用哪个代码片段可以输出此数组中的所有元素?","options":["for(int i;i<intArr.length;i++){\n System.out.println(intArr[i]+\"\");\n}","for(int i:intArr){\n  System.out.println(intArr[i]+\"\");\n}"," for(int i:intArr){\n  System.out.println(i + \"\");\n}","for(int i;i<intArr.length;i++){\n System.out.println(i + \"\");\ni++;\n}"," for(int i;i<intArr.length;i++){\n System.out.println(intArr[i]+ \"\");\n}"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n原题答案为CE，但是明显没有初始化值无法调用循环。实质上只有C选项可以遍历输出完数组"},{"questionType":0,"questionContent":"import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        List<String> lst = Arrays.asList(\"EN\",\"FR\",\"CH\",\"JP\");\n        Iterator<String> itr = lst.iterator();\n        while(itr.hasNext()) {\n            String e = itr.next();\n            if(e == \"CH\") {\n                break;\n            }\n            System.out.println(e + \"\");\n        }\n    }\n\n}","questionTitle":"请问结果是什么?","options":["EN FR JP","EN FR","EN FR CH","CH"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字符串相等判断，注意String并不是基本类型。如果在几个引用间传递，导致内存地址发生变化后，就有可能使==符号无法判断相等。"},{"questionType":0,"questionContent":"public class Test {\n    public static void main(String[] args) {\n        int[] codes = new int[5];\n        codes[1] = 10;\n        codes[1] = 20;\n        codes[1] = 30;\n        codes[1] = 40;\n        codes[1] = 50;\n        for(int i=1;i<codes.length;i++) {\n            System.out.println(codes[i]+\":\");\n        }\n    }\n\n}","questionTitle":"请问结果是什么?","options":["代码出现编译错误","50:\n0:\n0:\n0:","在line14抛出ArrayIndexOutOfBoundsException","在line10抛出ArrayIndexOutOfBoundsException"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n查无line 14 10, 原题没有正确答案我改了一下，这里是只设置了一个位置，然后其他都输出数组默认值0"},{"questionType":0,"questionContent":"interface Exportable{\n    void export();\n}\nclass Tool implements Exportable{\n    protected void export(){      //line n1\n        System.out.println(\"Tool::export\");\n    }\n}\nclass ReportTool extends Tool implements Exportable{\n    public void export(){    //line n2\n        System.out.println(\"RTool::export\");\n    }\n    public static void main(String[] args){\n        Tool aTool = new ReportTool();\n        Tool bTool = new Tool();\n        callExport(aTool);\n        callExport(bTool);\n    }\n    public static void callExport(Exception ex){\n        ex.export();\n    }\n}","questionTitle":"请问结果是什么?","options":["编译仅在line n2处失败","Tool::export\nTool::export","RTool::export\nTool::export 7.2-2","编译仅在line n1处失败","编译在line n1和line n2处均失败"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n实现的方法不应该定义为protected,因为接口中的方法是公开的public(实现类实现的方法访问权限不能低于被实现接口方法的访问权限).并且此处callExport方法调用的是Exception而不是Exportable"},{"questionType":0,"questionContent":"class E1 extends Exception{}\nclass E2 extends RuntimeException{}\npublic class App{\n    public void m1(){\n        System.out.println(\"m1.Accessed\");\n        throw new E1();\n    }\n\n    public void m2(){\n        System.out.println(\"m1.Accessed\");\n        throw new E2();\n    }\n    public static void main(String[] args){\n        int level = 1;\n        App obj = new App();\n        if(level <=5 && level >=3){\n            obj.m1();\n\n        }else{\n            obj.m2();\n        }\n    }\n\n} ","questionTitle":"下面哪项是正确的?","options":["程序打印出m1.Accessed.","程序由于不可处理的E1异常造成编译错误","程序由于不可处理的E2异常造成编译错误","程序打印出m2.Accessed"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没捕获错误和抛出错误，运行时错误一般不抛出，抛出也无法处理所以可以编译。但一般的Exps显式抛出时需要捕获"},{"questionType":1,"questionContent":"// ","questionTitle":"那三项描述了java语言的面向对象特征?","options":["对象之间可以共享行为","不能重用对象","Object是其他所有对象的根类","一个程序包必须包含超过一个的类","子类可以从超类继承","必须在每一个类中声明一个main方法"],"answers":[0,2,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n问的是面对对象，DF就问的牛头不对马嘴了，问的是特征所以排除B"},{"questionType":0,"questionContent":"package root;\npublic class Tree{\n    public void m1(){};\n    private void m2(){};\n    protected void m3(){};\n    void m4(){};\n}\n\npackage branch;\nimport root.*;\npublic class Plant extends Tree{\n\n}\n\nimport branch.Plant;\n\npublic class Test {\n    public static void main(String[] args) {\n        Plant t = new Plant();\n        /*在这里插入代码*/\n    }\n\n}\n","questionTitle":"请问插入下面哪项是正确的?","options":["t.m1();\nt.m3();\nt.m4();","t.m1();","t.m1();\nt.m3();",".t.m1();\nt.m4();"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n只有public 和 protected修饰的方法允许外包子类访问"},{"questionType":0,"questionContent":"import java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        List<String> arrayList = new ArrayList<>();\n        arrayList.add(\"Tech\");\n        arrayList.add(\"Expert\");\n        arrayList.set(0,\"java\");\n        arrayList.forEach(a -> a.concat(\"Forum\"));\n        arrayList.replaceAll(a -> a.concat(\"Group\"));\n        System.out.println(arrayList);\n    }\n\n}","questionTitle":"请问结果是什么?","options":["[JavaGroup,TechGroup,ExpertGroup]","[JavaGroup,ExpertGroup]","[JavaForumGroup,ExpertForumGroup]","[JavaForum,ExpertGroup]"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nconcat拼接是返回新字符串，这里遍历拼接完后未设置回list中，replace则是为每个字符串和concat链接后字符串进行替换"},{"questionType":1,"questionContent":"public class Rectangle {\n    private double length;\n    private double height;\n    private double area;\n\n    private void setLength(double length) {\n        this.length = length;\n    }\n\n    private void setHeight(double height) {\n        this.height = height;\n    }\n\n    private void setArea(double area) {\n        this.area = area;\n    }\n}","questionTitle":"那两项更改会封装此类,并确保无论何时使用Rectangle类,area字段始终等于length*height?","options":["在setHeight方法的结尾处调用setArea.","将area字段更改为public","将setArea更改为\tprivate","在setLength方法的开头处调用setArea方法","在setHeight方法的开头处调用setArea方法","在setArea方法的开头处调用setArea方法"],"answers":[3,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处忽略细节略多，调用setArea为(height*length)在两个方法设置值前时的话确实可以保证满足条件"},{"questionType":0,"questionContent":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Product {\n    String name;\n\n    int price;\n    public Product( int price,String name) {\n        this.name = name;\n        this.price = price;\n    }\n}\n\npublic class Shop {\n    public static void main(String[] args) {\n        List<Product> lst = new ArrayList<>();\n        lst.add(new Product(10, \"IceCream\"));\n        lst.add(new Product(11, \"Chccclate\"));\n        Product p1 = new Product(10, \"IceCream\");\n        System.out.println(lst.indexOf(p1));\n\n    }\n}","questionTitle":"请问结果是什么?","options":["true","false","0","-1"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n新建的对象和原本存储对象的内存地址不同，此处搜索不到返回-1"},{"questionType":1,"questionContent":"// ","questionTitle":"下面那两项数组初始化语句是正确的?","options":["int array[] = new int[3](1,2,3);","B.int array[] = new int[3];\narray = {1,2,3};","int array[3] = new int[]{1,2,3};","int array[] = new int[]{1,2,3};","int array[] = new int[3];"],"answers":[3,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n虽然是c语言风格的定义数组，但DE确实是正确的定义数组的两种方式，指定数组大小和初始化数组不能同时执行且有特定的位置"},{"questionType":0,"questionContent":"class Test {\n    int a1;\n\n    public static void doProduct(int a) {\n        a = a * a;\n    }\n\n    public static void doString(StringBuilder a) {\n        a.append(\" \" + a);\n    }\n\n    public static void main(String[] args) {\n        Test t1 = new Test();\n        t1.a1 = 11;\n        StringBuilder sb = new StringBuilder(\"Hello\");\n        Integer i = 0;\n        doProduct(i);\n        doString(sb);\n        doProduct(t1.a1);\n        System.out.println(i + sb.toString() + +t1.a1);\n    }\n}","questionTitle":"结果是什么?","options":["100 Hello Hello 121","0 Hello Hello 11","10 Hello Hello 121"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nBuilder自己拼接自己然后输出一个局部变量，基本类型int传值引用无法修改原始值,且该方法操作为0的平方，输出为0 Hello Hello 11"},{"questionType":1,"questionContent":"public class Test {\n    public static void main(String[] args) {\n        int x;\n        //插入代码\n    }\n}","questionTitle":"请问下面哪两个代码段插入后会打印出\n*\n*\n*\n?","options":["        x= 3;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x!=0);","        x= 0;\n        do{\n            System.out.println(\"*\");\n            x++;\n        }while(x>=3);","        x= 0;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x++<3);","        x= 3;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x>0);","        x= 0;\n        do{\n            System.out.println(\"*\");\n            ++x;\n        }while(x>1);"],"answers":[0,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n全 都 错 了，原本的所有选项都出不了答案，这里改了条件让两个能正确输出了\n(注，原题为***,此处所有输出都是换行输出)"},{"questionType":0,"questionContent":"class MyException extends RuntimeException{}\n\npublic class Test{\n    public static void main(String[] args){\n        try{\n            method1();\n        }catch(MyException ne){\n            System.out.println(\"A\");\n        }\n    }\n    public static void method1(){\n        try{\n            throw Math.random()>0.5?new MyException() :new RuntimeException();\n        }catch(RuntimeException re){\n            System.out.println(\"B\");\n        }\n    }\n}","questionTitle":"结果是什么?","options":["在line n1处发生编译错误","A或B","B","AB","A"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n看似是高贵的随机错误，实际上一看这不俩都是RuntimeException，所以实际只会输出B"},{"questionType":0,"questionContent":"public class Test {\n    public static void  main(String[] args){\n        int[] stack = {10,20,30};\n        int size = 3;\n        int idx = 0;\n        /* line n1*/\n        System.out.println(\"The Top Element:\"+stack[idx]);\n    }\n}","questionTitle":"在line n1处插入那个代码片段能够输出\nThe Top Element:30 ?","options":["A.while(idx<size){\nidx++;\n}","do{\n            idx++;\n        }while(idx>=size);","do{\n            idx++;\n        }while(idx<=size);","while(idx<=size-1){\nidx++;\n}","do{\n            idx++;\n        }while(idx <size - 1);"],"answers":[4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n注意边界条件"},{"questionType":1,"questionContent":"public class Test{\n    public static void main(String[] args){\n        //index n1\n        switch (x){\n            case 1:\n                System.out.println(\"One\");\n                break;\n            case 2:\n                System.out.println(\"Two\");\n                break;\n        }\n    }\n}","questionTitle":"在line n1处插入哪三个代码片段可使该代码输出One?","options":["String x = 1;","short x = 1;","byte x = 1;","Integer x = new Integer(1);","double x = 1;","double x = 1;"],"answers":[1,2,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nswitch不支持double和long"},{"questionType":0,"questionContent":"package p1;\npublic class Acc{\n    int p;\n    private int q;\n    protected int r;\n    public int s;\n}\n\npackage p2;\n\nimport p1.Acc;\n\npublic class Test extends Acc {\n    public static void main(String[] args) {\n        Acc obj = new Test();\n    }\n}","questionTitle":"哪项描述是正确的?","options":["r和s都可以通过obj访问","p和s都可以通过obj访问","仅s可以通过obj访问","p,r和s都可以通过obj访问"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n类型为Acc,但跨包引用实质上可访问只有公开的public s可被访问"},{"questionType":0,"questionContent":"class s1{\n    protected void display(int x){\n        System.out.println(\"Parent\"+x );\n    }\n}\nclass s2 extends s1{\n    public void display(int x,int y){\n        this.display(x);\n        display(y);\n        super.display(y);\n    }\n    public void display(int x){\n        System.out.println(\"Child\" + x);\n    }\n\n}\n\npublic class Test{\n    public static void main(String[] args){\n        s2 sobj = new s2();\n        sobj.display(10,100);\n    }\n}","questionTitle":"请问结果是什么?","options":["Child10\nChild100\nParent100","Child10\nParent100\nParent 100","出现一个编译错误\n","Parent10\nChild10\nParent1000"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n调用父类方法和本类方法"},{"questionType":0,"questionContent":"public class StockRoom {\n    private  int stock = 10;\n    private static int qty = 0 ;\n    public void purchase(int qty) {\n        StockRoom.qty = qty;\n        stock += qty;\n    }\n\n    public void sell(int qty) {\n        StockRoom.qty = qty;\n        stock -= qty;\n    }\n    public void printStock(String action) {\n        System.out.println(action + \":\" + qty + \" items. Stock in Hand:\" + stock);\n    }\n\n    public static void main(String[] args) {\n        StockRoom k1 = new StockRoom();\n        k1.sell(5);\n        k1.printStock(\"Sold\");\n        StockRoom k2 = new StockRoom();\n        k2.purchase(5);\n        k2.printStock(\"Purchased\");\n\n    }\n}","questionTitle":"希望打印的结果如下:\nSold: 5 items. Stock in Hand:5\nPurchased: 5 items.Stock in Hand:10\n下面哪项改变可以正确打印?","options":["将变量Stock的方法purchase(),sell()和printStock都定义成Static.","将变量 stock,qty和方法printStock()定义成static","将变量stock和方法printStock()定义为static","将变量stock定义为static."],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n非静态方法可以自由调用静态方法和变量，但是重新初始化的对象不会保存非静态变量的值。因为静态变量的作用域独立存在，所以重复初始化仍可保留值的变化"},{"questionType":0,"questionContent":"public class Bird{\n    public void fly(){\n        System.out.println(\"Fly.\");\n    }\n}\npublic class Peacock extends Bird{\n    public void dance(){\n        System.out.println(\"Dance.\");\n    }\n}\npublic class Test{\n    public static void main(String[] args){\n        /*在这里插入代码*/\n        p.fly();\n        p.dance();\n    }\n}","questionTitle":"下面哪个选项插入后会打印出\nFly.\nDance.?","options":[" Bird b = new Peacock();\n Peacock p =(Peacock) b;","Bird p = new Peacock();","Peacock b = new Peacock();\nBird p = (Bird)b;","Bird b = new Bird();\nPeacock p = (Peacock)b;"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n父类不应该向下转型"},{"questionType":0,"questionContent":"class C1 {\n}\n\nclass C2 extends C1 {\n}\n\nclass C3 extends C2 {\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        C1 obj1 = (C1) new C2();    // line 16\n        C2 obj2 = (C2) new C3();    // line 17\n        C2 obj3 = (C2) new C1();    // line 18\n        C3 obj4 = obj2;             // line 19\n    }\n}","questionTitle":"请问哪一行抛出classCastException?","options":["line 17","line 16","line 18","line 19"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n转换成父类后向下转型仍旧会编译错误,注意这题问的不是哪里会编译失败(line19向下转型会导致编译不通过)\n按抛出错误的行来说，c1向下转型成c2会更早抛出castExps"},{"questionType":0,"questionContent":"import java.time.LocalDate;\n\npublic class Test {\n    public static void main(String[] args) {\n        LocalDate date = LocalDate.of(2012,01,32);\n        date.plusDays(10);\n        System.out.println(date);\n    }\n}","questionTitle":"结果是什么?","options":["2012-02-10","编译失败","在运行时引发DateTimeException","2012-02-11"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n非法的日期输出会运行错误"},{"questionType":0,"questionContent":"class Vehicle {\n    String type = \"4w\";\n    int maxSpeed = 100;\n\n    Vehicle(String type, int maxSpeed) {\n        this.type = type;\n        this.maxSpeed = maxSpeed;\n    }\n}\n\nclass Car extends Vehicle {\n    String trans;\n\n    Car(String trans) {  //line n1\n        this.trans = trans;\n    }\n\n    Car(String type, int maxSpeed, String trans) {\n        super(type, maxSpeed);\n        this(trans); //line n2\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n\n        Car c1 = new Car(\"Auto\");\n        Car c2 = new Car(\"4w\", 150, \"Manual\");\n        System.out.println(c1.type + +c1.maxSpeed + +c1.trans);\n        System.out.println(c2.type + +c2.maxSpeed + +c2.trans);\n    }\n}","questionTitle":"结果是什么?","options":["编译仅在line n2处失败","编译仅在line n1处失败","编译仅在line n1和line n2处均失败","null 0 Auto\n4w 150 Manual"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n未super实现父类无参构造函数，注意子类的每个构造方法都会显式或隐式的调用父类的构造方法。\n\n即linen1处会隐式地调用无参构造函数但是父类未提供实现，且未通过super调用已存在的父类构造方法\n\nline2处 super和this方法不能在同一个构造函数内重复使用，因为他们都需要存在于一个构造函数的第一行"},{"questionType":0,"questionContent":"\n\npublic class Test {\n    public static void main(String[] args) {\n\n        int sum = 0;\n        for(int xVal=1;xVal<=5;xVal++){ \n            sum =sum+xVal;\n        }\n        System.out.println(\"The sum of\"+xVal+\"number is:\"+sum);\n    \n    }\n}","questionTitle":"结果是什么?","options":["The num of 5 number is : 15","The num of 5 number is : 10","编译错误","The num of 4 number is : 10"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nfor定义的变量只能在for循环体内使用"},{"questionType":0,"questionContent":"public class Person{\n    String name;\n    int age = 25;\n    public Person(String name){\n        this(); // line n1\n        setName(name);\n    }\n    public Person(String name,int age){\n        Person(name); // line n2\n        setAge(age);\n    }\n    //setter and getter methods go here\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String show(){\n        return name+ +age;\n    }\n\n    public static void main(String[] ages){\n        Person p1 = new Person(\"Jesse\");\n        Person p2 = new Person(\"Walter\",52);\n        System.out.println(p1.show());\n        System.out.println(p2.show());\n\n\n    }\n}","questionTitle":"结果是什么?","options":["编译仅在line n2处失败","Jesse 25\nWalter 52","编译仅在line n1处失败","编译仅在line n1和line n2处失败"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没有定义无参构造方法，linen2处是在新建实例"},{"questionType":0,"questionContent":"\n\npublic class Test {\n    public static void main(String[] args) {\n        int[][] arr = new int[2][4];\n        arr[0] = new int[]{1, 3, 5, 7};\n        arr[1] = new int[]{1, 3};\n        for (int[] a : arr) {\n            for (int i : a) {\n                System.out.println(i + \"\");\n            }\n            System.out.println();\n        }\n    }\n}","questionTitle":"结果是什么?","options":["1 3 5 7\n1 3","1 3\n 1 3 0 0","1 3\n随后引发ArrayIndexOutOfBoundsException","编译失败"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n遍历嵌套数组"},{"questionType":0,"questionContent":"\n\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sObj = new StringBuilder(\"java \");\n        System.out.println(sObj.indexOf(\"the\"));\n        sObj.append(\"the Great\");\n        System.out.println(sObj.indexOf(\"the\"));\n    }\n}","questionTitle":"结果是什么?","options":["false\n 6","-1\n-1","0\n 5","-1\n5"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nindexOf找不到返回-1"},{"questionType":0,"questionContent":"\n\npublic class Test {\n    public static void main(String[] args){\n        String[][] chs = new String[2][]\n        chs[0] = new String[2];\n        chs[1] = new String[2];\n        int i = 97;\n\n        for(int a = 0;a<=chs.length;a++){\n            for(int b=0;b<chs.length;b++){\n                chs[a][b] = \"\"+i;\n            }\n        }\n        for(String[] ca:chs){\n            for(String c:ca){\n                System.out.println(c+ \"\");\n            }\n            System.out.println();\n        }\n    }\n}","questionTitle":"结果是什么?","options":["97\n97\n\n97\n97","a\na\n\na\na","编译错误","运行引发越界错误"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数组最后一个索引是length-1，注意边界条件"},{"questionType":0,"questionContent":"import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class Test {\n    public static void main(String[] args){\n        String date = LocalDate.parse(\"2014-05-04\").format(DateTimeFormatter.ISO_DATE_TIME);\n        System.out.println(date);\n    }\n}","questionTitle":"结果是什么?","options":["5/4/14T00:00:00.000","2014-05-04T00:00:00.000","May 04,2014T00:00:00.000","在运行时抛出异常错误"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n传入的是日期字符串，转换的是时间DATE_TIME(不包含小时分钟等无法正确转换)此模式可用于格式化ISO-8601日期时间字符串，但不能用于格式化日期字符串。"},{"questionType":0,"questionContent":"\npublic class Test {\n    public static void main(String[] args) {\n        String grade = \"B\";\n        if (grade == \"A\" || grade == \"1\") {\n            System.out.println(\"First Grade\");\n        } else if (grade == \"B\") {\n            System.out.println(\"Second Grade\");\n        } else {\n            System.out.println(\"Third Grade\");\n        }\n    }\n}","questionTitle":"下面哪项Switch语句重构if/else语句正确,并且打印出Second Grade?","options":["switch(grade){\n            case \"A\":\n            case \"1\":\n                System.out.println(\"First Grade\");\n                break;\n            case \"B\":\n                System.out.println(\"Second Grade\");\n                break;\n        }\n        System.out.println(\"Third Grade\");"," switch (grade) {\n            case \"A\":\n            case \"1\":\n                System.out.println(\"First Grade\");\n                break;\n            case \"B\":\n                System.out.println(\"Second Grade\");\n                break;\n            default:\n                System.out.println(\"Third Grade\");\n        }"," switch(grade){\n            case \"A\": case \"1\":\n                System.out.println(\"First Grade\");\n            case \"B\":\n                System.out.println(\"Second Grade\");\n            default:\n                System.out.println(\"Third Grade\");\n\n        }","switch(grade){\n            case \"A\" || \"1\":\n                System.out.println(\"First Grade\");\n            case \"B\":\n                System.out.println(\"Second Grade\");\n            default:\n                System.out.println(\"Third Grade\");\n\n        }"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n布尔值或判断||要两边是布尔值类型，switch case判断后应及时break跳出循环避免往下继续判断(除非连续条件)"},{"questionType":0,"questionContent":"\npublic class Test {\n    public static void main(String[] args){\n        int x;\n        /*insert code here*/\n    }\n}","questionTitle":"请问下面哪个代码可打印:Welcome 100?","options":[" x=100;\n        while (x<=100){\n            x++;\n            System.out.println(\"Welcome\" +x);\n        }","for(x=0;x<100;++x){\n            System.out.println(\"Welcome\" +x);\n        }","for(x=0;x<=100;++x){\n            System.out.println(\"Welcome\" +x);\n        }"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n注意循环边界条件"},{"questionType":0,"questionContent":"public class Test {\n    public static final int MIN = 1;\n\n    public static void main(String[] args) {\n        int x = args.length;\n        if (checkLimit(x)) { //line n1\n            System.out.println(\"Java SE\");\n        } else {\n            System.out.println(\"Java EE\");\n        }\n    }\n\n    public static boolean checkLimit(int x) {\n        return (x >= MIN) ? true : false;\n    }\n}","questionTitle":"假定运行以下命令:\njavac Test.java\njava Test\n结果是什么?","options":["Java SE","编译在line n1处失败","Java EE","在运行时引发NullPointerException"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没传参数长度为0"},{"questionType":0,"questionContent":"class Vehicle{\n    int x;\n    Vehicle(){\n        this(10); //line n1;\n    }\n    Vehicle(int x){\n        this.x = x;\n    }\n}\nclass Car extends Vehicle{\n    int y;\n    Car(){\n        super();\n        this(20); //line n2\n    }\n    Car(int y){\n        this.y = y;\n    }\n    public String toString(){\n        return super.x+ \":\" + this.y;\n    }\n}\npublic class Test {\n\n    public static void main(String[] args) {\n        Vehicle y = new Car();\n        System.out.println(y);\n    }\n\n}","questionTitle":"结果是什么?","options":["编译在line n1处失败","编译在line n2处失败","10:20","0:20"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n一个构造函数中 super和this只能同时用一个"},{"questionType":1,"questionContent":"public class Customer{\n    public String name;\n    public Account account;\n\n}\npublic class Account{}","questionTitle":"请问哪两个动作封装了Customer类?","options":["定义了Account类为private","利用构造函数初始化name和account属性","定义name和account属性为private","为name和account属性创建了private final setter和private getter方法","为name和account属性创建了public setter 和public getter方法","定义name属性为private 并且定义account属性为final"],"answers":[2,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n封装指将字段私有修饰并提供公开方法以获取修改"},{"questionType":1,"questionContent":"public class Employee{\n    String name;\n    boolean contract;\n    double salary;\n    Employee(){\n        //line n1\n    }\n    public String toString(){\n        return name+\":\"+contract+\"：\"+salary;\n    }\n    public static void main(String[] args){\n        Employee e = new Employee();\n        //line n2\n        System.out.println(e);\n    }\n\n}","questionTitle":"单独进行那两项修改可使该代码输出Joe:true:100.0?","options":["将line  n1替换为\nthis.name = new String(\"Joe\");\nthis.contract = new Boolean(true);\nthis.salary = new Double(100);","将line  n1替换为\nname = \"Joe\";\ncontract = true;\nsalary = 100;","将line n1替换为\nthis(\"Joe\",true,100);","将line n2替换为\n\n        name = \"Joe\";\n        contract = true;\n        salary = 100;"],"answers":[0,1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n构造函数内可初始值"},{"questionType":0,"questionContent":"public class MyField{\n    int x;\n    int y;\n    public void doStuff(int x,int y){\n        this.x= x;\n        y = this.y;\n    }\n    public void display(){\n        System.out.println(x+\" \"+y+ \":\");\n    }\n    public static void main(String[] args){\n        MyField m1 = new MyField();\n        m1.x = 100;\n        m1.y = 200;\n        MyField m2 = new MyField();\n        m2.doStuff(m1.x,m1.y);\n        m1.display();\n        m2.display();\n\n    }\n}","questionTitle":"结果是什么?","options":["100 0 :\n100 0 :","100 0:\n100 200 :","100 200 :\n100 200;","100 200:\n100 0;"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ndoStuff中将类中局部变量中的值赋值给形式参数，这不会改变局部变量，所以m2的y是整形的默认值0"},{"questionType":0,"questionContent":"\nclass Student{\n    String name;\n    int age;\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        Student s2 = new Student(); // line 11\n        Student s3 = new Student();\n        s1 = s3;\n        s3 = s2;\n        s2 = null;\n    }\n\n}","questionTitle":"哪项描述是正确的?","options":["在第11行后,一个对象符合垃圾收集条件","在第11行后，三个对象符合垃圾收集条件","在第11行后,两个对象符合垃圾收集条件","在第11行后,没有任何对象符合垃圾收集条件"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ns1的引用指向了s3，s3的引用指向了s2，s2指向null然后这条引用链上就全为null了，那么三个对象都符合垃圾收集条件了"},{"questionType":0,"questionContent":"public class Test{\n    public static void main(String[] args){\n        int numbers[] = {12,13,42,32,15,156,23,51,12};\n        int max = findMax(numbers);\n    }\n    /*line n1*/{\n        int max = 0;\n        /* code goes here */\n        return max;\n\n    }\n}","questionTitle":"在line n1处使用那个方法签名是正确的?","options":["static int[] findMax(int max)","static int findMax(int[] numbers)","public int findMax(int[] numbers)","final int findMax(int[])"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n静态方法main内调用的方法也需要是静态方法"},{"questionType":1,"questionContent":"//","questionTitle":"哪两个类定义会编译失败?","options":["class A4{\n    protected static final int i;\n    private void doStuff(){}\n}","final class A1{\n    public A1(){}\n}","final abstract class A5{\n    protected static int i;\n    void dostuff(){}\n    abstract void doIt();\n}","public class A2{\n    private static int i;\n    private A2(){}\n}"],"answers":[0,2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nfinal修饰的字段需要初始化一个值(定义一个修改不了的空值没有意义)，因为意味着不可修改。\n而可拓展的抽象类是不应该加上不可修改的final修饰符的。"},{"questionType":1,"questionContent":"abstract class Toy{\n    int price;\n    //line n1\n}","questionTitle":"那三个代码片段在line n1处有效? ","options":["public abstract int computeDiscount();","public int calculatePrice(){\n        return price;\n    }","public static void insertToy(){\n        /* code goes here*/\n    }","private A2(){}","public abstract Toy getToy(){\n        return new Toy();\n    }"],"answers":[0,1,2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nabstract字段修饰的抽象方法不应该有方法体，有效指的是有实际意义，封装一个私有的构造函数(且名字不同于定义的类)在这里明显是不合法的"},{"questionType":1,"questionContent":"//","questionTitle":"下面那两项关于可以被检测的exception 是正确的? ","options":["它会在编译时期被检测","它是RuntimeException的子类","他不能被再次throw","它必须用try-catch块或者被thrown定义处理","它是error的父类"],"answers":[0,3],"analysis":"\n\nerror和exception同级，看名字就知道不会是runTimeExps子类，可以被重复抛出"},{"questionType":1,"questionContent":"//","questionTitle":"请问关于Java application类封装的2个特性是什么?","options":["编译时期多态","数据隐藏","数据抽象化","内存数据优化","数据验证"],"answers":[1,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这个我也不到啊，可能是想说能用私有修饰符隐藏字段隐藏数据，set数据前能校验验证数据吧\n(个人认为答案应该是隐藏和抽象数据，这也是封装的主要特性)"},{"questionType":0,"questionContent":"//","questionTitle":"下面哪个组件使得java应用程序独立于平台? ","options":[".java文件","JVM","JDK",".class文件"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\njvm是java虚拟机，有java虚拟机就可以在不同平台上运行相同的字节码文件"},{"questionType":1,"questionContent":"public class Test{\n//line n1\n}","questionTitle":"下面那两项可以插入line n1?","options":["package p1;","for(int iVal=0;iVal<=5;iVal++){}","import java.io.*;","String str =\"java\";","Test(){}"],"answers":[3,4],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n基本程序结构("},{"questionType":0,"questionContent":"class Cart {\n    Product p;\n    double totalAmount;\n}\n\nclass Product {\n    String name;\n    Double price;\n}\n\npublic class Shop {\n    public static void main(String[] args) {\n        Cart c = new Cart();\n        System.out.println(c.p + \":\" + c.totalAmount);\n    }\n}","questionTitle":"请问结果是什么?","options":["null:null","B.null:null:0.0","<<HashCode>>:0.0","null:0.0"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\np未初始化默认值null"},{"questionType":0,"questionContent":"public class Maintest {\n    public static void main(int[] args) {\n        System.out.println(\"int main\" + args[0]);\n    }\n    public static void main(Object[] args) {\n        System.out.println(\"Object main\" + args[0]);\n    }\n    public static void main(String[] args) {\n        System.out.println(\"String main\" + args[0]);\n    }\n}","questionTitle":"运行以下命令：\njavac Maintest.java\njava Maintest 1 2 3\n结果是什么?","options":["Object main1","int main1","编译失败","String main1","在运行时引发异常错误"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n重载不同方法，一般都是走默认方法即String[] args(优先级最高)，执行顺序一般之后是 char charcter int integer "},{"questionType":1,"questionContent":"package clothing.pants;\n// line n1\npublic class Jeans {\n    public void matchShirt(){\n        // line n2\n        if (color.equals(\"Green\")) {\n            System.out.println(\"Fit\");\n        }\n    }\n    public static void main(String[] args) {\n        Jeans trouser = new Jeans();\n        trouser.matchShirt();\n    }\n}","questionTitle":"单独进行哪两组操作可使该代码片段输出Fit?","options":["在line n1处插入：import static clothing.Shirt.getColor;\n在line n2处插入：String color = getColor();","在line n1处插入：import clothing.Shirt;\n在line n2处插入：String color = getColor();","在line n1处插入：import clothing.*;\n在line n2处插入：String color = Shirt.getColor();","在line n1处插入：import clothing;\n在line n2处插入：String color = Shirt.getColor();","在line n2处插入：String color = Shirt.getColor();"],"answers":[0,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nimport static 是静态导入，导入相应的静态字段和静态方法，这里调用后就可以直接使用(具体的代码细节不管) 此处getColor明显是个静态方法所以导入相应包后可以直接通过类名调用。而另一个选项则是获取当前包下所有类以获取某个类的静态方法。\n"},{"questionType":0,"questionContent":"public class Triangle {\n    static double area;\n    int b = 2, h = 3;\n    public static void main(String[] args) {\n        double p, b, h; // line n1\n        if (area == 0) {\n            b = 3;\n            h = 4;\n            p = 0.5;\n        }\n        area = p * b * h; // line n2\n        System.out.println(\"Area is \" + area);\n    }\n}","questionTitle":"结果是什么?","options":["Area is 3.0","Area is 6.0","编译在line n1处失败。","编译在line n2处失败。"],"answers":[3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n在if语句块内初始化外部area赋值时调用不到，就被默认当成引用main内的局部变量然后出现未初始值的编译错误\n"},{"questionType":0,"questionContent":"public class Test{\n    public static void main(String[] args) {\n        String[][] chs = new String[2][];\n        chs[0] = new String[2];\n        chs[1] = new String[5];\n        int i = 97;\n        for (int a = 0; a < chs.length; a++) {\n            for (int b = 0; b < chs.length; b++) {\n                chs[a][b] = \"\" + i;\n                i++;\n            }\n        }\n        for (String[] ca : chs) {\n            for (String c : ca) {\n                System.out.print(c + \" \");\n            }\n            System.out.println();\n        }\n    }\n}","questionTitle":"结果是什么?","options":["97 98 \n  99 100 null null null","97 98 \n  99 100 101 102 103","在运行时引发NullPointerException","编译失败","在运行时引发ArrayIndexOutofBoundsException"],"answers":[0],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nString默认值就是null，未设置值的String数组默认值也一样是null\n"},{"questionType":1,"questionContent":"public class Shape {\n    int m;\n    int l;\n\n    //line n1\n    public Shape() {\n        this.l = 100;\n        this.m = 100;\n    }\n\n    public Shape(int l, int m) {\n        this.l = l;\n        this.m = m;\n    }\n\n    public void print() {\n        System.out.print(l + \" : \" + m);\n    }\n\n    public static void main(String[] args) {\n        Shape sh = new Shape(1000);\n        sh.print();\n    }\n}","questionTitle":"下面在line n1处哪个构造器定义可以打印出100 : 1000?","options":["    public Shape(int m) {\n        this.l = 100;\n        this(this.l, this.m);\n    }","public Shape(int m) {\n    this.m = m;\n    this(100, this.m);\n}","public Shape(int m) {\n    this(100, m);\n}","public Shape(int m) {\n    this();\n    this.l = 100;\n    this.m = m;\n}"],"answers":[2,3],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nthis在构造函数中需要放在第一行，this调用构造函数时不能使用this调取实例内变量，会造成二义性(应该)"},{"questionType":0,"questionContent":"public class Test{\n    public static void main(String[] args) {\n        Short s1 = 200;\n        Integer s2 = 400;\n        Long s3 = (long) s1 + s2; // line n1\n        String s4 = (String) (s3 * s2); // line n2\n        System.out.println(\"Sum is \" + s4);\n    }\n}","questionTitle":"结果是什么?","options":["在 line n2 处引发 classCastException。","Sum is 600","编译在 line n2 处失败","在 line n1 处引发 classCastException。"],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数值等类型是不能直接强转字符串类型的，一般通过拼接字符串来转型或者String.valueOf()"},{"questionType":0,"questionContent":"public class Test{\n    public static void main(String[] args) {\n        int[] codes = new int[5];\n        codes[1] = 10; // line 10\n        codes[2] = 20;\n        codes[3] = 30;\n        codes[4] = 40;\n        codes[5] = 50; // line 14\n        for (int i = 1; i < codes.length; i++) {\n            System.out.println(codes[i] + \" : \");\n        }\n    }\n}","questionTitle":"结果是什么?","options":["10 : 20 : 30 : 40 : 50 :","代码出现编译错误.","在line 14抛出ArrayIndexOfBoundsException.","在line 10抛出ArrayIndexOfBoundsException."],"answers":[2],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n明目张胆的越界错误，数组下标范围是0到length-1\n\n我也不知道为什么是line 10 和 14，直接不改了"},{"questionType":0,"questionContent":"import java.util.ArrayList;\n\npublic class Test{\n    public static void main(String[] args) {\n        ArrayList myList = new ArrayList();\n        String[] myArray;\n        try {\n            while (true) {\n                myList.add(\"My String\");\n            }\n        } catch (RuntimeException re) {\n            System.out.println(\"Catch a RuntimeException\");\n        } catch (Exception e) {\n            System.out.println(\"Catch a Exception\");\n        }\n        System.out.println(\"Ready to use\");\n    }\n}","questionTitle":"结果是什么?","options":["在第一个 catch 语句终止执行，并在控制台输出 Catch a RuntimeException","在线程 main 中引发运行时错误","在第二个 catch 语句终止执行，并在控制台输出 Catch a Exception","正常完成执行，并在控制台输出 Ready to use","该代码编译失败，因为需要 throws 关键字"],"answers":[1],"analysis":"*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n死循环且不退出，最终会在main线程发生堆溢出的oom错误"}]}