{"questions": [{"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n该题考的是字符串equal和==的区别，其中equal是比较值，==是比较内存地址。因为字符串不同对象的内存地址不同，即使他们值一样用==也往往无法得到预期结果，所以这里结果为false,true D", "answer": "0001", "content": "class Equal{\n    public static void main(String[] erge){\n        String str1= \"Java\";\n        String[] str2= {\"J\",\"a\",\"v\",\"a\"};\n        String str3 = \"\";\n        for(String str : str2) \n            str3= str3+str;\n        boolean b1 =(str1==str3);\n        boolean b2 = (str1.equals(str3));\n        System.out.println(b1+\",\"+b2);\n    }\n}\n", "id": 1, "options": ["false,false", "true,false", "true,true", "false,true"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考核数值中_的使用，_在数值中仅用于划分数值不会影响原本值，故var1结果为12456\n两个浮点数相加所以结果为12456.0+1024.0 = 13480.0选A", "answer": "1000", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        float var1 = (12_345.01 >= 123_45.00) ? 12_456 : 124_56.02f ; \n        float var2 = var1+1024;\n        System.out.print(var2);\n    }\n}\n", "id": 2, "options": ["13480.0", "13480.02", "编译失败", "在运行时引发异常错误"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain方法因为需要被jvm在外部调用所以访问权限需要为public，而java代码执行是通过jvm虚拟机找到main方法调用。而jvm虚拟机被jre java运行环境包含，所以说是会被jre调用也算正确\n", "answer": "0101", "content": "//", "id": 3, "options": ["它是一个final方法", "必须定义为public类", "如果在运行时执行成功，那么将会返回true", "会被JRE调用"], "title": "请问关于main()方法正确的是哪俩项?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n选择Vehicle是MotorCycle的父类则满足多态性，所以F是正确的，而 Vehicle 是MotorCycle类实现的接口.因为MotorCycle已经实现了Vehicle接口，所以作为Vechicle接口列表的myList可以成功存放MotorCycle的实例，故D也正确", "answer": "000101", "content": "ArreyList<Vehicle> myList = new ArrayList<>();\nmyList.add (new MotorCycle());", "id": 4, "options": ["Vehicle 和MotorCycle均继承Transportation超类(父类)", "Vehicle 和MotorCycle均实现Transportation接口", "MotorCycle是实现Vehicle 类的接口", "Vehicle 是MotorCycle类实现的接口", "MotorCycle是Vehicle 的超类(父类)", "Vehicle 是MotorCycle 的超类(父类)"], "title": "如果哪两项描述成立(符合其中任何一项)， 代码即可通过编译?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处考的是方法传递参数的值传递和引用传递，这里isAvailable方法传入的x因为是基本类型所以只会复制一份值传入，修改其中的值不会改变原始的变量。所以这里会一直返回true造成死循环。所以需要在循环内为变量做自减操作以保证循环可终止，故选C", "answer": "0010", "content": "public class Test {\n\tpublic static void main(String[] args){\n\t\t\tint x=5;\n\t\t\twhile(isAvailable(x)){\n\t\t\t\t// line1\n\t\t\t\tSystem .out.print(x);\n\t\t\t\t// line2\n\t\t\t}\n\t\t}\n\t\tpublic static boolean isAvailable(int x){\n\t\t\t//line3\n\t\t\treturn x-- > 0 ? true : false;\n\t\t}\n}", "id": 5, "options": ["将第line1行注释语句替换为System.out.print(--x);", "将第line3行注释语句替换为return (x>0) ? false:true;", "在第line2行插入x--;", "将第 line1行注释语句替换为--x; 并在line2行插入System.out.print(x);"], "title": "哪项修改可使该代码输出54321?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处考的是变量的作用域，大括号{}内被视作一个作用域，作用域只能调用外部的但不能调用内部.即此处line4行的color因为调用了switch语句内作用域定义的变量color而会出现编译错误所以选B", "answer": "0100", "content": "public class Test {\n\tpublic static void main(String[] args) {\n\t\tchar colorCode = 'y';\n\t\tswitch (colorCode) {\n\t\t\tcase 'r':\n\t\t\t\t// line1\n\t\t\t\tint color = 100;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\t// line2\n\t\t\t\tcolor = 10;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\t// line3\n\t\t\t\tcolor = 1;\n\t\t\t\tbreak;\n\t\t}\n\t\t// line4\n\t\tSystem.out.println(color);\n\t}\n}", "id": 6, "options": ["在line1行出现编译错误.", "在line4行出现编译错误", "在line2和line3行出现编译错误", "打印出:1"], "title": "请问结果是什么? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n静态方法只能调用静态变量，此处process方法调用非静态变量foo所以会编译错误，故选A", "answer": "1000", "content": "\npublic class App {\n    int foo;\n    static int bar;\n\n    static void process() {\n\t\tfoo += 10;\n\t\tbar += 10;\n\t}\n\n    public static void main(String[] args) {\n        App firstObj = new App();\n        App.process();\n        System.out.println(firstObj.bar);\n        App secondObj = new App();\n        App.process();\n        System.out.println(secondObj.bar);\n    }\n}\n", "id": 7, "options": ["编译时出现错误", "10\n10", "10\n20", "20\n20"], "title": "请问结果是什么? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nRuntimeException指的是运行时异常，指编译器不强制要求处理的异常，所以不需要特意捕获。此处因为process方法抛出了方法却没有使用try catch捕获或在方法上使用throws继续向上抛出所以会编译错误，选项中可取的只有A，在 方法名() 后增加throws语句将内部抛出错误继续向上抛出", "answer": "1000", "content": "class LogFileException extends Exception{}\nclass AccessViolationException extends  RuntimeException{}\n\npublic class App {\n\t// line1\n\tpublic static void main(String[] args) throws LogFileException {\n\t\tApp obj = new App();\n\t\ttry{\n\t\t\t\n\t\t\t// line2\n\t\t\t//代码插入在这里\n\t\t}\n\t\tcatch(Exception e){\n\t\t\t\tSystem. out.println(\"Completed.\");\n\t\t}\n\t}\n\t// line3\n\tpublic void process() {\n\t\tSystem.out.println(\"Processed\");\n\t\tthrow new LogFileException();\n\t}\n\t// line4\n\tpublic void open(){\n\t\tSystem.out.println(\"Opened.\");\n\t\tthrow new AccessViolationException ();\n\t}\n}\n", "id": 8, "options": ["在line3行，插入throws LogFileException ", "在line1行，将throws AccessViolationException 替换为throws LogFileException ", "在line2行，插入throw new LogFileException();", "在line4行插入throws AccessViolationException "], "title": "请问下面哪项可以修正编译错误? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考的是变量默认初始值和方法的两种参数传递方式。首先输出App和Book的两个没有指定值的整型变量，因为整型变量默认初始值为0，所以先输出0:0\n然后通过内置方法调用传递了一个对象引用和一个基本变量去修改值，这里方法传递时传递如数组，对象等是引用传递，即修改传递入的变量会影响原本的变量。而像整型等基本变量则只是传值进去，修改传递变量不会影响原变量。所以这里objBook.pages被修改为100,而count则没有变化。因此输出100:0,故选A", "answer": "1000", "content": "class Book {\n\tint pages;\n}\n\npublic class App {\n\tint count;\n\tpublic void method(Book x, int k) {\n\t\tx.pages = 100;\n\t\tk = 200;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tApp obj = new App() ;\n\t\tBook objBook = new Book() ;\n\t\tSystem.out.println(objBook.pages +\":\"+ obj.count);\n\t\tobj .method (objBook, obj.count) ; \n\t\tSystem.out.println(objBook.pages +\":\"+ obj.count);\n\t}\n}", "id": 9, "options": ["0:0 \n100:0", "null : null\n100 : null", "0: 0\n100 : 200", "0: 0\n200 :100"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处是将数组转换为list之后遍历，题目要求是输出AB，则原本代码执行逻辑应该为判断为C则中断循环，遍历到其他字符则进行判断，这里line3处是直接跳到下一个循环，使后面line4的输出语句直接执行不到，会造成编译错误。也无法输出AB，所以只要注释掉continue即line3就可以输出AB，故选A", "answer": "1000", "content": "import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tList<String> lst = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\t\tIterator<String> itr = lst.iterator();\n\t\twhile (itr.hasNext()) {\n\t\t\tString e = itr.next();\n\t\t\tif (e == \"C\") {\n\t\t\t\tbreak;// line1\n\t\t\t} else {// line2\n\t\t\t\tcontinue;// line3\n\t\t\t\tSystem.out.print(e);// line4\n\t\t\t}// line5\n\t\t}\n\t}\n}", "id": 10, "options": ["注释掉line3", "注释掉line2", "注释掉line1", "注释掉line2到line5"], "title": "请问哪项可以打印出AB?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n简单的字符串api考察，只使用了拼接字符串和替换字符串，但是这里替换后的字符串没有赋值给原字符串所以replace这一行语句实际不会有结果，所以输出为ABCC选C", "answer": "00100", "content": "\npublic class Test {\n\tpublic static void main(String[] args){\n\t\t\tString ta = \"A\";\n\t\t\tta = ta.concat(\"B\");\n\t\t\tString tb = \"C\";\n\t\t\tta = ta.concat(tb);\n\t\t\tta.replace(\"C\",\"D\");\n\t\t\tta = ta.concat(tb);\n\t\t\tSystem.out.println(ta);\n\t\t}\n}", "id": 11, "options": ["A B C D", "A C D", "A B C C", "A B D", "A B D C"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察遍历二维数组，A选项内层循环的终止条件是小于上一层的索引，无法遍历完二维数组。所以选B", "answer": "01", "content": "\npublic class Test {\n\tpublic static void main(String[] args){\n\t\tString shirts[][] = new String[2][2];\n\t\tshirts[0][0]=\"red\";\n\t\tshirts[0][1]=\"blue\";\n\t\tshirts[1][0]=\"small\";\n\t\tshirts[1][1]=\"medium\";\n\t}\n}", "id": 12, "options": ["for (int index = 0;index < 2; ++index) {\n\t\t\tfor (int idx=0; idx < index; ++idx) {\n\t\t\t\tSystem.out.print (shirts[index][idx] + \":\");\n\t\t\t}\n\t\t}", "for (int index = 0;index < 2; ) {\n\t\t\tfor (int idx=0; idx < 2; ) {\n\t\t\t\tSystem.out.print (shirts[index][idx] + \":\");\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tindex++;\n\t\t"], "title": "哪个代码片段能遍历shirts数组输出\nred:blue: small:medium:?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项循环内给循环条件赋值为固定值，只会死循环\nB选项终止循环条件是idx=1，此时输出不到第一项\n\nC选项 变量--先执行算术操作再返回变量，循环条件结束idx为1时可以正常自减为0获取第一个元素所以正确\n\nD选项 --变量是先返回值再执行算术操作，所以第一次循环会先从列表大小值获取元素发生越界错误，改成变量--可以正确输出", "answer": "0010", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Test {\n\tpublic static void main(String[] args){\n\t\tList<String> lst = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\t\t/* insert code here */\n\t\t\n\t}\n}", "id": 13, "options": ["\t\tint idx = 0;\n\t\twhile(idx>=0){\n\t\t\tidx = lst.size();\n\t\t\tSystem.out.print(lst.get(--idx));\n\t\t}", "int idx = lst.size()-1;\n\t\twhile(idx>=1){\n\t\t\tSystem.out.print(lst.get(idx));\n\t\t\tidx--;\n\t\t}", "int idx = lst.size();\n\t\t while(idx>=1){\n\t\t\t System.out.print(lst.get(--idx));\n\t\t }", "int idx = lst.size();\n\t\twhile(idx>0){\n\t\t\tSystem.out.print(lst.get(idx--));\n\t\t}"], "title": "插入哪个代码段可以打印出DCBA?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项 即使是变量赋值也在后面才定义所以会报引用错误，而且最后没有加引号和分号\n\nB选项 双精度浮点数后缀加大小写d都是正确的\n\nC选项 int的包装类Integer，可以正常赋值，赋值的过程被称作自动装箱\n\nD选项 布尔值变量值都是小写", "answer": "0110", "content": "// ", "id": 14, "options": ["String tmpAuthor = author, author = Mo Donald", "Double price = 200D;", "Integer pages = 20;", "Boolean available = TRUE;"], "title": "下面哪两个初始化语句是正确的?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这是考察对错误的理解，这里checkCard抛出的RuntimeExps是非检查的运行时异常，属于运行时才能发现的通常是代码逻辑的异常，一般不用抛出，抛出了也无法处理。而Exception默认异常是用于警醒使用者代码调用处可能会发生的异常，不捕获就会编译错误。故在line n3处编译失败", "answer": "10000", "content": "public class Test{\n    void readCard(int cardNo) throws Exception{\n        System.out.println(\"Reading Card\");\n    }\n    void checkCard(int cardNo) throws RuntimeException{ //line n1\n        System.out.println(\"Checking Card\");\n    }\n    public static void main(String[] args){\n        Test ex = new Test();\n        int cardNo = 12344;\n        ex.checkCard(cardNo);\t\t//line n2\n        ex.readCard(cardNo);\t\t//line n3\n    }\n}", "id": 15, "options": ["编译仅在line n3处失败", "编译仅在line n1处失败", "Reading Card\nChecking Card", "编译仅在line n2处失败", "编译在line n2和line n3处均失败"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nLong类型是一个对象(注意大小写)，需要使用对象实例化或者valueOf()方法将int类型的vI转换为Long类型。因此，可以使用Integer c1 = vI或者Long c1 = Long.valueOf(vI)来使编译通过。\n\nint和long可以自动转换，但是Integer和Long是不同的基本类型的包装类，需要使用相应的构造函数或valueOf()方法来进行转换。同样的情况也适用于float和double类型的转换。", "answer": "1000", "content": "public class App{\n  public static void main(String[] args){\n      int vI = 10;\n      float vF = 100.05f;\n      Long c1 = vI; // line 5\n      long c2 = vI; // line 6\n      float c3 = vF; // line 7\n      double c4 = vF; // line 8\n  }\n}", "id": 16, "options": ["用Integer c1 = vI替换line 5;", "用Long c2 = vI替换line 6:", "用float e3 =vF替换line 7 :", "用Double C4 = vF替换line 8 ;"], "title": "请问下面哪个选项可以修正错误? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处是泛型继承，调取的是父类的方法所以除了m1都无法访问。因为m2是私有只能Tree内部类访问，m3只能同一个包内的子类内访问，m4默认访问修饰也是同一包内可访问\n\n*该题与原答案冲突", "answer": "100", "content": "////////////Tree//////////////\npackage root;\npublic class Tree{\n    public void m1(){}\n    private void m2(){}\n    protected void m3(){}\n    void m4(){}\n}\n////////////Plant//////////////\npackage branch;\n\nimport root.*;\npublic class Plant extends Tree{\n    public void m1(){}\n    public void m2(){}\n    public void m3(){}\n    public void m4(){}\n}\n////////////Test//////////////\nimport branch.Plant;\nimport root.Tree;\n\npublic class Test{\n    public static void main(String[] args){\n        Tree t = new Plant();\n        // line 10\n    }\n}\n", "id": 17, "options": ["t.m1();", "t.m1();\nt.m3();", "t.m1();\nt.m3();\nt.m4();"], "title": "[存疑]假设Tree.java和Plant.java文件的内容如下：\n请问在line10 插入下面哪项是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数组是引用传递，赋值不会新建数组而是将原数组引用传递，所以此处array2和array3实际上都赋值成了array1\n即输出都是1 2 3选D\n", "answer": "0001", "content": "\npublic class Test{\n    public static void main(String[] args){\n        int array1[] ={1,2,3};\n        int array2[] = new int[5];\n        array2 = array1;\n        for(int i : array2){\n            System.out.print(i+\" \");\n        }\n        System.out.println();\n        int array3[] = new int[3];\n        array3 = array2;\n        for(int i : array3){\n            System.out.print(i+\" \");\n        }\n    }\n}", "id": 18, "options": ["1 2 3 0 0\n1 2 3 0 0", "运行时抛出异常（Exception）", "1 2 3 0 0\n1 2 3", "1 2 3\n1 2 3"], "title": "请问结果是什么? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察字符串api使用，trim是去除首尾空格。charAt获取字符指定位置字符，此处为S，indexOf是查找字符索引，后一个参数是指定开始寻找的索引。不加则从0开始，此处从第一位开始查找即从\"weet Sweat\"查找Sw,即输出6\n答案选D S 6", "answer": "0001", "content": "\npublic class Test{\n    public static void main(String[] args){\n        String str = \"Sweet Sweat\";\n        String str2 = str.trim().charAt(6) + \" \" + str.indexOf(\"Sw\",1);\n        System.out.println(str2);\n    }\n}", "id": 19, "options": ["S 5\t", "w 7", "-1", "S 6"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nemm...意义不明的考察，匹配条件全部不匹配那只能是输出默认的default下的E了", "answer": "0001", "content": "\npublic class Test{\n    public static void main(String[] args){\n        String option = \"j\";\n        switch(option){\n            case \"1\":\n                System.out.print(\"A\");\n            case \"2\":\n            case \"4\":\n                System.out.print(\"B\");\n                break;\n            case \"3\":\n            case \"5\":\n                System.out.print(\"C\");\n            default:\n                System.out.print(\"E\");\n        }\n    }\n}", "id": 20, "options": ["C", "CE", "ABCE", "E"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察访问修饰符，这里public可以给外部类公共访问所以m1可覆盖，m3是同包内继承子类可访问所以也可以覆盖。而默认不加修饰符只能同包内访问，此处两个类不在同一个包，不可以覆盖，m2是私有方法也不能覆盖。", "answer": "0110", "content": "////////////////////Customer///////////////////////\npackage sales;\n\npublic class Customer {\n    public void m1(){}\n    private void m2(){}\n    protected void m3(){}\n    void m4(){}\n}\n////////////////////Trader///////////////////////\npackage market;\n\nimport sales.*;\npublic class Trader extends Customer{\n    \n}", "id": 21, "options": ["m2()", "m3()", "m1()", "m4()"], "title": "假设Customer.java 和 Trader.java文件的内容如下，下面哪两个Customer类的方法可以被Trader类覆盖?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ncontinue语句用于循环中进入下一次循环，不能在单独的switch语句中使用。所以选B注释掉line2", "answer": "0100", "content": "public class Shop {\n    public static void main(String[] args) {\n        int price = 1000;\n        int qty = 2;\n        String grade = \"2\";\n        double discount = 0.0;\n        switch (grade) {\n            case \"1\":\n                discount = price * 0.1;\n                break; // line 1\n            case \"2\":\n                discount = price * 0.5;\n                continue; // line 2\n            default:\n                System.out.println(\"Thank You!\");\n        }\n        System.out.println(discount);\n    }\n}", "id": 22, "options": ["程序执行并且输出：\n500.0", "注释掉line 2使得程序输出：\nThank You!\n500.0", "程序执行并且输出：\nThank You!\n500.0", "注释掉line 1使得程序输出：\nThank You!\n500.0"], "title": "请问哪一项是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n父类无法访问到继承的子类的字段，所以B和F试图访问子类的字段都会导致编译失败", "answer": "010001", "content": "class Employee{\n    public int salary;\n}\n\nclass Manager extends Employee{\n    public int budget;\n}\n\nclass Director extends Manager{\n    public int stockOptions;\n}\n\npublic class Test{\n\n    public static void main(String[] args){\n        Employee employee = new Employee();\n        Manager manager = new Manager();\n        Director director = new Director();\n        //line n1\n        \n    }\n\n}", "id": 23, "options": ["director.stockOptions = 1_000;", "manager.stockOption = 500;", "director.salary = 80_000;", "employee.salary  = 50_000;", "manager.budget = 1_000_000;", "employee.budget = 200_000;"], "title": "哪两个选项放置在main方法的line n1处会编译失败?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain中第一行使用多态将Game类使用本身实现了的Playerable接口定义，抽象则表现为interface接口中定义的两个方法，封装则是将players字段和相关方法封装在Game类中，故选A。", "answer": "1000", "content": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Player{}\n\ninterface Playable{\n    public void play();\n    public void setPlayers(List<Player> players);\n}\n\nclass Game implements Playable{\n    private List<Player> players;\n    public List<Player> getPlayers(){ return players; }\n    public void setPlayers(List<Player> players){ this.players = players;  }\n    public void play() { System.out.println(\"Played.\"); }\n}\npublic class Test{\n\n    public static void main(String[] args){\n        Playable p = new Game();\n        List<Player> players  = new ArrayList<>();\n        p.setPlayers(players);\n\n    }\n\n}", "id": 24, "options": ["应用了多态，抽象和封装", "只应用了继承和封装", "应用了多态，继承和抽象", "只应用了多态和继承"], "title": "关于上面的定义和代码段对于面向对象编程概念的应用，哪个描述是对的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\njava字节码指java文件编译后的class文件，因为是编译后文件所以编译器不是必须的，但想要运行class文件需要具有java运行时环境JRE以执行字节码文件，故A描述符合", "answer": "10000", "content": "//", "id": 25, "options": ["它可以在具有Java运行时环境的任何平台上运行。", "它可以在具有Java编译器的任何平台上运行。", "它可以在任何平台上运行。", "它只能在编译时指定平台上运行。", "它只能在具有Java运行时环境和Java编译器的平台上运行"], "title": "关于Java字节码，哪项描述是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ninstanceof判断对象是否实例化于指定类型，此处r1通过P1实例化，跟作为自身子类的P2进行实例化判断会返回false，而实现了接口的类根据多态的原则是可以通过接口实例化的所以r3也是true，所以选B", "answer": "0100", "content": "class P1{}\nclass P2 extends P1 implements I1{}\ninterface I1{}\n\n\npublic class Test{\n\n    public static void main(String[] args){\n        P1 obj = new P1();\n        P2 obj2 = new P2();\n        I1 obj3 = new P2();\n        boolean r1 = obj instanceof P2;\n        boolean r2 = obj2 instanceof P1;\n        boolean r3 = obj3 instanceof I1;\n        System.out.println(r1 + \":\" + r2 + \":\" + r3);\n\n    }\n\n}", "id": 26, "options": ["true:false:true", "false:true:true", "true:true:false", "false:true:false"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项比并没有调用menu方法可以直接排除，而且for初始条件为0，读取在判断非0后，没有循环的条件。B选项是先执行后循环，所以必定显示菜单，其余代码也符合条件故正确。C选项因为没有初始值所以需要循环判断等于0，但因此输入0时还会继续运行不满足第三点，D选项没有定义相应初始值无法进行循环。", "answer": "0100", "content": "public class Game{\n    public static void menu(){\n        System.out.println(\"1.Left \\n2. Right \\n0. Stop\");\n    }\n    public static void main(String[] args){\n        int option;\n        /* insert code here */\n        \n    }\n}", "id": 27, "options": ["for (option = 0; option != 0; \n     option =  /* code that reads the option goes here */){\n     /* code that print the option go here  */\n}", "do{\n     menu();\n     option = //code that reads the option goes here\n     /* code that print the option go here*/\n}while(option != 0);", "while (option >= 0 ){\n     menu();\n     option = //code that reads the option goes here\n     /* code that print the option go here*/\n}", "while(option != 0){\n     menu();\n     option = //code that reads the option goes here\n     /* code that print the option go here*/\n}"], "title": "应用程序需求如下：\n1.菜单（menu）必须被显示\n2.被选择的选项必须被打印\n3.直到读到 '0' ，否则必须循环执行\n下面的代码段满足需求的是哪个?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n抽象类实现接口可以不实现方法，但具体类EBook继承层级中包含的接口方法都应该被实现，此处line n3处EBook未实现Downloadable中的抽象方法所以会编译失败", "answer": "00100", "content": "interface Downloadable{\n    public void download();\n}\n\n\ninterface Readable extends Downloadable{\t//line n1\n    public void readBook();\n}\n\nabstract class Book implements Readable{\t//line n2\n    public void readBook(){\n        System.out.println(\"Read Book\");\n    }\n}\n\nclass EBook extends Book{\t\t\t//line n3\n    public void readBook(){\n        System.out.println(\"Read E-Book\");\n    }\n}\npublic class Test{\n\n    public static void main(String[] args){\n        Book book1 = new EBook();\n        book1.readBook();\n\n    }\n\n}", "id": 28, "options": ["Read Book", "编译在line n1处失败", "编译在line n3处失败", "编译在line n2 处失败", "Read E-Book"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这里是实例化类之后调用greet，默认会调取成员变量，又因为构造函数中只是新建了同名的局部变量所以不会影响本身的成员变量，因此输出的只是默认的Welocome", "answer": "0001", "content": "public class App{\n    String greet = \"Welcome!\";\n    public App(){\n        String greet = \"Hello!\";\n    }\n\n    public void setGreet(){\n        String greet = \"Good Day!\";\n    }\n    public static void main(String[] args){\n        App t = new App();\n        String greet = \"Good Luck!\";\n        System.out.println(t.greet);\n    }\n}", "id": 29, "options": ["Hello!", "Good Luck!", "Good Day!", "Welcome!"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA是增加一个构造方法以适应main中的错误构建实例，故正确，B中看似正确，但是this方法应该放在构造方法首行所以是错误的，并且即使this换到第一行也不应在其中使用后续定义的this.m，C是新建构造方法并且通过硬编码的方式为l赋值，输出的结果是符合的所以正确。D选项和B是同样的错误不重复赘述", "answer": "0010", "content": "public class Shape{\n    int m;\n    int l;\n    //line n1\n\n    public Shape(){\n        this.l = 100;\n        this.m = 100;\n    }\n    public Shape(int l, int m){\n        this.l = l;\n        this.m = m;\n    }\n    public void print(){\n        System.out.print(l+\" : \"+m);\n    }\n    public static void main(String[] args){\n        Shape sh = new Shape(1000);\n        sh.print();\n    }\n}", "id": 30, "options": ["public Shape(int m){\n\tthis();\n\tthis.l = 100;\n\tthis.m = m\n}", "public Shape(int m){\n\tthis.m = m;\n\tthis(100,this.m);\n}", "public Shape(int m){\n\tthis(100,m);\n}", "public Shape(int m){\n\tthis.l = 100;\n\tthis(this.l,this.m);\n}"], "title": "请问下面在line n1处增加哪个构造器定义可以打印出100 ： 1000?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nB继承A且未单独新定义同名字段，故两个静态类调用同一个变量，所以最后都是赋值成200，输出则是调用各自定义的静态方法，所以选D", "answer": "0001", "content": "\nclass A {\n\tstatic int hitCount;\n\n\tstatic void printHitCount() {\n\t\tSystem.out.println(\"A class \" + hitCount);\n\t}\n}\n\nclass B extends A {\n\tstatic void printHitCount() {\n\t\tSystem.out.println(\"B class \" + hitCount);\n\t}\n}\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\tA.hitCount = 100;\n\t\tB.hitCount = 200;\n\t\tA.printHitCount();\n\t\tB.printHitCount();\n\t}\n\n}", "id": 31, "options": ["A class 100\nA class 200", "B class 200\nB class 200", "A class 100\nB class 200", "A class 200\nB class 200"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nA选项判断结果是大于80都是0.2，小于80则无法大于等于90只能为0。\nB选项三元表达式得到0.2条件为80<qty<90满足条件故正确。\nC选项前面满足条件，但后一个判断中else重复赋值导致前一个选项结果被覆盖因此错误。\nD选项重复判断两次但是未将条件放在一起导致最后只是判断>80则为0.2，错误。\nE选项将位于80和90之间和大于等于90的条件分开判断，但是不影响后一个if循环满足条件能得出正确值", "answer": "01001", "content": "\npublic class Test{\n\n    public static void main(String[] args){\n        double discount = 0;\n        int qty = Integer.parseInt(args[0]);\n        //line n1;\n        \n    }\n\n}", "id": 32, "options": ["discount = (qty > 80) ? 0.2 : (qty >= 90) ? 0.5 : 0;", "discount = (qty >= 90) ? 0.5 : (qty > 80) ? 0.2 : 0;", "if (qty > 80 && qty <90){\n\t\tdiscount = 0.2;\n\t}else{\n\t\tdiscount = 0;\n\t}\n\tif (qty >= 90){\n\t\tdiscount = 0.5;\n\t}else{\n\t\tdiscount = 0;\n\t}", "discount = (qty >= 90) ? 0.5 : 0;\n\tdiscount = (qty > 80) ? 0.2 : 0;", "if (qty >= 90) {\n            discount = 0.5;\n        }\n        if (qty > 80 && qty < 90) {\n            discount = 0.2;\n        }"], "title": "如果qty变量的值大于或等于90，则discount = 0.5\n  如果qty变量的值介于80和90之间，则discount=0.2\n在line n1处单独放入哪两个代码片段可满足这些需求?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n三目表达式问号数量和冒号数量不匹配", "answer": "00100", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int x = 100;\n        int a = x++;\n        int b = ++x;\n        int c = x++;\n        int d = (a<b) ? (a<c) ? a : (b<c) ? b:c;\n        System.out.println(d);\n    }\n\n}", "id": 33, "options": ["101", "100", "编译失败", "103", "102"], "title": "假定代码片段如下，结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n该题使用集合的removeIf方法删除变量，但是原代码意义不明，使用了lmbda表达式就不应该定义a的参数类型了，这里表达式中的是删除条件(而且此处s未定义)，理论上应该删除Hi然后返回的，但是输出语句中是获取不到lmbda定义的a的所以应该是编译失败", "answer": "0100", "content": "//////////原代码\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        String[] arr = {\"Hi\", \"How\", \"Are\", \"You\"};\n        List<String> arrList = new ArrayList<>(Arrays.asList(arr));\n        if (arrList.removeIf((String a) -> {\n            return s.length() <= 2;\n        })) {\n            System.out.println(a + \"removed\");\n        }\n    }\n\n}", "id": 34, "options": ["Hi removed", "编译失败", "在运行时引发UnsupportedOperationException", "该程序会通过编译,但不输出任何内容."], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字符串相等判断通过equal才能判断值相等，直接==判断的是内存地址一般都不相等，所以&&判断第一个为false直接短路输出B，然后大小写忽略判断值，输出C 则最终输出BC", "answer": "0100", "content": "\nclass OraString{\n    String s;\n    public boolean equals(OraString str){\n        return this.s.equalsIgnoreCase(str.toString());\n    }\n    OraString(String s){\n        this.s = s;\n    }\n}\npublic class Test {\n\n    public static void main(String[] args) {\n        String s1 = \"Moon\";\n        OraString s2 = new OraString(\"Moon\");\n\n        if((s1==\"Moon\")&&(s2.equals(\"Moon\"))) {\n            System.out.println(\"A\");\n        }else {\n            System.out.println(\"B\");\n        }\n\n        if(s1.equalsIgnoreCase(s2.s)) {\n            System.out.println(\"C\");\n        }else {\n            System.out.println(\"D\");\n        }\n    }\n\n}", "id": 35, "options": ["BD", "BC", "AD", "AC"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n因为一直死循环添加内容，最后会占满虚拟机的堆内存抛出OutOfMemoryError错误\n\nJava中的RuntimeException以及其子类是属于非受检异常（Unchecked Exception），它们在编译时不要求强制捕获或声明抛出。这意味着即使你显式地使用catch语句来捕获RuntimeException，仍然无法捕获到像内存溢出（OutOfMemoryError）这样的错误，包括堆占满导致的OOM。\n\nOutOfMemoryError是Error的子类，它属于Java中的受检异常（Checked Exception）。与RuntimeException不同，受检异常在编译时要求强制捕获或者在方法签名中声明抛出。但是，OutOfMemoryError以及其他Error类型的异常通常被认为是不可恢复的，因为它们表示了严重的系统问题，例如内存耗尽，无法通过程序来处理。", "answer": "00100", "content": "import java.util.ArrayList;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        ArrayList myList = new ArrayList();\n        String[] myArray;\n        try {\n            while (true) {\n                myList.add(\"My String\");\n            }\n        } catch (RuntimeException re) {\n            System.out.println(\"Caught a RuntimeException\");\n        } catch (Exception e) {\n            System.out.println(\"Caught an  Exception\");\n        }\n        System.out.println(\"Ready to use\");\n    }\n\n}", "id": 36, "options": ["在第一个catch语句终止执行,并在控制台输出Caught an Exception", "在第二个catch语句终止执行,并在控制台输出Caught an Exception", "在main线程中抛出一个运行时错误。", "正常完成执行,并在控制台输出Ready to use", "由于需要一个 throw 关键字，代码编译失败。"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n未声明area变量调用", "answer": "0001", "content": "\npublic class Test {\n\n    int b = 2, h=3;\n    public static void main(String[] args) {\n        double p,b,h;\n        if(area == 0) { // line n1\n            b = 3;\n            h = 4;\n            p = 0.5;\n        }\n        area = p*b*h; // line n2\n        System.out.println(\"Area is\" +area);\n\n    }\n\n}", "id": 37, "options": ["Area is 3.0", "编译在n2处失败", "Area is 6.0", "编译在n1处失败"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nD选项还沾点边，BC选项就是占位了，所以选强关联的AE\n", "answer": "10001", "content": "// 无题干", "id": 38, "options": ["自动的错误日志", "优化后的代码", "对象之间的通信", "程序执行的流程控制", "错误类型"], "title": "当应用了异常处理(Exception Handing)技术以后,我们可以从java程序中得到那两项功能?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n这题甚至没给实例代码和答案，实例是我编的，只要知道C1也可以调用C2的方法就可以了，这里C1也实现了接口方法不会编译错误。", "answer": "0001", "content": "class C2{\n    public void display2(){\n        System.out.println(\"C2\");\n    }\n}\ninterface I{\n    public void displayI();\n}\nclass C1 extends C2 implements I{\n    public void displayI(){\n        System.out.println(\"C1\");\n\n    }\n\n}\npublic class Test {\n    public static void main(String[] args) {\n       C1 c1 = new C1();\n       C2 c2 = new C2();\n       c1.displayI();\n       c2.display2();\n    }\n\n}", "id": 39, "options": ["编译失败", "C1\nC1", "C2\nC2", "C1\nC2"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nmain方法作为入口是没有返回值的，jre用于执行java文件确实会调用到main方法，不定义为public就无法使外部编译器调用到了，所以选BD", "answer": "0101", "content": "// 无题干", "id": 40, "options": ["它是一个final方法", "必须定义为public", "如果在运行时执行成功,将会返回true", "会被JRE调用."], "title": "请问关于main方法正确的是?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n考察对命令执行的理解，执行java命令时文件名后带的参数会通过args传递进程序，此处b接受null转换为布尔值为false，故输出true false选E\n\n*注意jdk9以后使用构造函数转换布尔值方法已被废弃", "answer": "00001", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        boolean a = new Boolean(Boolean.valueOf(args[0]));\n        boolean b = new Boolean(args[1]);\n        System.out.println(a+\" \"+b);\n    }\n\n}", "id": 41, "options": ["TRUE NULL", "true true", "false false", "在运行时抛出ClassCastException", "true false"], "title": "假定运行以下命令\njavac Test.java\njava Test TRUE null\n结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n空字符匹配，但是StringBuilder的equal默认是比较内存地址，所以匹配会失败，只有sb转换成String之后执行equals才是进行值匹配，所以返回Match 2 选B", "answer": "0100", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(5);\n        String s = \"\";\n        if(sb.equals(s)) {\n            System.out.println(\"Match 1\");\n        }else if(sb.toString().equals(s.toString())) {\n            System.out.println(\"Match 2\");\n        }else {\n            System.out.println(\"No Match\");\n        }\n    }\n\n}", "id": 42, "options": ["No Match", "Match 2", "运行时引发NullPointException", "Match 1"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n同名方法重复定义声明，不重载参数只会编译失败", "answer": "00001", "content": "public class MainTest{\n\n    public static void main(String[] args) {\n        System.out.println(\"int main \"+ args[0]);\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Object main\" + args[0]);\n\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"String main\" + args[0]);\n\n    }\n}", "id": 43, "options": ["在运行时引发一场错误", "String main 1", "Object main 1", "int main 1", "编译失败"], "title": "运行以下命令\njavac MainTest.java\njava MainTest 1 2 3\n结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字太多看的头疼，接口中是不能定义带有方法体的方法的，所以为了满足交通工具类的公共方法这一条件AD直接排除，然后C覆盖所有方法也不满足公共方法这一条件，所以选B", "answer": "0100", "content": "// ", "id": 44, "options": ["1.创建定义了start()和stop()方法的交通工具接口,并且定义ride()抽象方法\n2.创建应用交通工具接口的客车类和船类.", "B.创建了一个定义了stop()方法,start()方法的抽象类交通工具,并且拥有抽象方法ride().\n创建继承自交通工具类的客车类和船类,并且覆盖了ride()方法", "C.创建一个定义了stop()方法,start()方法的抽象类交通工具,并且拥有抽象方法ride().\n创建继承自交工工具类的客车类和船类,并且覆盖所有的方法", "D.创建了一个定义了默认stop()方法,start()方法的交通工具接口(interface),和一个ride()方法\n创建了应用交通工具接口的客车类和船类,并且覆盖ride()方法."], "title": "客车与船都是交通工具(Vehicle类)，方法start()和stop()是交通工具(Vehicle类)的公共方法\n方法ride()用于表示每一种交通工具(Vehicle)类的特殊方法\n下面哪个选项符合上述描述?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n不是必须在发生错误的地方处理错误，标准错误无法涵盖所有错误", "answer": "01101", "content": "// ", "id": 45, "options": ["由于必须在发生异常错误的方法中处理异常错误,因此改进了程序结构", "由于程序可以选择处理异常错误的位置,因此改进了程序结构.", "允许创建新异常错误,可以针对要创建的特定程序定制异常错误", "提供一组标准异常错误,涵盖所有可能的错误", "由于错误处理代码与正常程序功能分离,因此改进了程序结构"], "title": "哪三项是java异常错误机制的优势?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nm方法先抛出错误，所以先输出blue purple，然后捕获到运行时错误输出yellow。接着程序会执行finally块跳过后续代码(抛出Exps那行)，所以选D", "answer": "0001", "content": "public class App{\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"blue\");\n            m();\n            throw new Exception();\n        }catch(RuntimeException re) {\n            System.out.println(\"yellow\");\n        }catch(Exception e) {\n            System.out.println(\"green\");\n        }finally {\n            System.out.println(\"orange\");\n        }\n\n    }\n    public static void m() {\n        System.out.println(\"purple\");\n        throw new RuntimeException();\n    }\n}", "id": 46, "options": ["blue\npurple\nyellow\ngreen\norange", "blue\npurple\norange", "blue\ngreen\norange", "blue\npurple\nyellow\norange"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n实例化子类会默认调用父类的构造函数，两个构造函数内输出都会执行。", "answer": "1000", "content": "class Vehicle{\n    Vehicle(){\n        System.out.println(\"Vehicle\");\n    }\n}\nclass Bus extends Vehicle{\n    Bus(){\n        System.out.println(\"Bus\");\n    }\n}\npublic class Transport{\n    public static void main(String[] args) {\n        Vehicle v = new Bus();\n    }\n}", "id": 47, "options": ["Vehicle\nBus", "B.程序不会打印任何内容", "Bus", "Bus\nVehicle"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n原题答案为CE，但是没有初始化声明的i的值，无法调用循环(A同)。实质上只有C选项可以遍历输出完数组", "answer": "00100", "content": "int [] intArr = {8,16,32,64,128};", "id": 48, "options": ["for(int i;i<intArr.length;i++){\n System.out.println(intArr[i]+\"\");\n}", "for(int i:intArr){\n  System.out.println(intArr[i]+\"\");\n}", "for(int i:intArr){\n  System.out.println(i + \"\");\n}", "for(int i;i<intArr.length;i++){\n  System.out.println(i + \"\");\n  i++;\n}", "for(int i;i<intArr.length;i++){\n  System.out.println(intArr[i]+ \"\");\n}"], "title": "单独使用哪个代码片段可以输出此数组中的所有元素?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n字符串相等判断，注意String并不是基本类型。如果在几个引用间传递，导致内存地址发生变化后，就有可能使==符号无法判断相等。", "answer": "0100", "content": "import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        List<String> lst = Arrays.asList(\"EN\",\"FR\",\"CH\",\"JP\");\n        Iterator<String> itr = lst.iterator();\n        while(itr.hasNext()) {\n            String e = itr.next();\n            if(e == \"CH\") {\n                break;\n            }\n            System.out.println(e + \"\");\n        }\n    }\n\n}", "id": 49, "options": ["EN FR JP", "EN FR", "EN FR CH", "CH"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n查无line 14 10, 原题没有正确答案我改了一下，这里是只设置了一个位置，然后其他都输出数组默认值0", "answer": "0100", "content": "public class Test {\n    public static void main(String[] args) {\n        int[] codes = new int[5];\n        codes[1] = 10;\n        codes[1] = 20;\n        codes[1] = 30;\n        codes[1] = 40;\n        codes[1] = 50;\n        for(int i=1;i<codes.length;i++) {\n            System.out.println(codes[i]+\":\");\n        }\n    }\n\n}", "id": 50, "options": ["代码出现编译错误", "0:\n50:\n0:\n0:\n0:", "在line14抛出ArrayIndexOutOfBoundsException", "在line10抛出ArrayIndexOutOfBoundsException"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n实现的方法不应该定义为protected,因为接口中的方法是公开的public(实现类实现的方法访问权限不能低于被实现接口方法的访问权限).并且此处callExport方法调用的是Exception而不是Exportable", "answer": "00010", "content": "interface Exportable{\n    void export();\n}\nclass Tool implements Exportable{\n    protected void export(){      //line n1\n        System.out.println(\"Tool::export\");\n    }\n}\nclass ReportTool extends Tool implements Exportable{\n    public void export(){    //line n2\n        System.out.println(\"RTool::export\");\n    }\n    public static void main(String[] args){\n        Tool aTool = new ReportTool();\n        Tool bTool = new Tool();\n        callExport(aTool);\n        callExport(bTool);\n    }\n    public static void callExport(Exception ex){\n        ex.export();\n    }\n}", "id": 51, "options": ["编译仅在line n2处失败", "Tool::export\nTool::export", "RTool::export\nTool::export 7.2-2", "编译仅在line n1处失败", "编译在line n1和line n2处均失败"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没捕获错误和抛出错误，运行时错误一般不抛出，抛出也无法处理所以可以编译。但一般的Exps显式抛出时需要捕获B", "answer": "0100", "content": "class E1 extends Exception{}\nclass E2 extends RuntimeException{}\npublic class App{\n    public void m1(){\n        System.out.println(\"m1.Accessed\");\n        throw new E1();\n    }\n\n    public void m2(){\n        System.out.println(\"m1.Accessed\");\n        throw new E2();\n    }\n    public static void main(String[] args){\n        int level = 1;\n        App obj = new App();\n        if(level <=5 && level >=3){\n            obj.m1();\n\n        }else{\n            obj.m2();\n        }\n    }\n\n} ", "id": 52, "options": ["程序打印出m1.Accessed.", "程序由于不可处理的E1异常造成编译错误", "程序由于不可处理的E2异常造成编译错误", "程序打印出m2.Accessed"], "title": "下面哪项是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n问的是面对对象，DF就问的牛头不对马嘴了，问的是特征所以排除B", "answer": "101010", "content": "// ", "id": 53, "options": ["对象之间可以共享行为", "不能重用对象", "Object是其他所有对象的根类", "一个程序包必须包含超过一个的类", "子类可以从超类继承", "必须在每一个类中声明一个main方法"], "title": "那三项描述了java语言的面向对象特征?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n只有public 和 protected修饰的方法允许外包子类访问", "answer": "0010", "content": "package root;\npublic class Tree{\n    public void m1(){};\n    private void m2(){};\n    protected void m3(){};\n    void m4(){};\n}\n\npackage branch;\nimport root.*;\npublic class Plant extends Tree{\n\n}\n\nimport branch.Plant;\n\npublic class Test {\n    public static void main(String[] args) {\n        Plant t = new Plant();\n        /*在这里插入代码*/\n    }\n\n}\n", "id": 54, "options": ["t.m1();\nt.m3();\nt.m4();", "t.m1();", "t.m1();\nt.m3();", "t.m1();\nt.m4();"], "title": "请问插入下面哪项是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nconcat拼接是返回新字符串，这里遍历拼接完后未设置回list中，replace则是为每个字符串和concat链接后字符串进行替换", "answer": "0100", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        List<String> arrayList = new ArrayList<>();\n        arrayList.add(\"Tech\");\n        arrayList.add(\"Expert\");\n        arrayList.set(0,\"java\");\n        arrayList.forEach(a -> a.concat(\"Forum\"));\n        arrayList.replaceAll(a -> a.concat(\"Group\"));\n        System.out.println(arrayList);\n    }\n\n}", "id": 55, "options": ["[JavaGroup,TechGroup,ExpertGroup]", "[JavaGroup,ExpertGroup]", "[JavaForumGroup,ExpertForumGroup]", "[JavaForum,ExpertGroup]"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n此处忽略细节略多，调用setArea为(height*length)在两个方法设置值前时的话确实可以保证满足条件", "answer": "000110", "content": "public class Rectangle {\n    private double length;\n    private double height;\n    private double area;\n\n    private void setLength(double length) {\n        this.length = length;\n    }\n\n    private void setHeight(double height) {\n        this.height = height;\n    }\n\n    private void setArea(double area) {\n        this.area = area;\n    }\n}", "id": 56, "options": ["在setHeight方法的结尾处调用setArea.", "将area字段更改为public", "将setArea更改为\tprivate", "在setLength方法的开头处调用setArea方法", "在setHeight方法的开头处调用setArea方法", "在setArea方法的开头处调用setArea方法"], "title": "那两项更改会封装此类,并确保无论何时使用Rectangle类,area字段始终等于length*height?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n新建的对象和原本存储对象的内存地址不同，此处搜索不到返回-1", "answer": "0001", "content": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Product {\n    String name;\n\n    int price;\n    public Product( int price,String name) {\n        this.name = name;\n        this.price = price;\n    }\n}\n\npublic class Shop {\n    public static void main(String[] args) {\n        List<Product> lst = new ArrayList<>();\n        lst.add(new Product(10, \"IceCream\"));\n        lst.add(new Product(11, \"Chccclate\"));\n        Product p1 = new Product(10, \"IceCream\");\n        System.out.println(lst.indexOf(p1));\n\n    }\n}", "id": 57, "options": ["true", "false", "0", "-1"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n虽然是c语言风格的定义数组，但DE确实是正确的定义数组的两种方式，指定数组大小和初始化数组不能同时执行且有特定的位置", "answer": "00011", "content": "// ", "id": 58, "options": ["int array[] = new int[3](1,2,3);", "B.int array[] = new int[3];\narray = {1,2,3};", "int array[3] = new int[]{1,2,3};", "int array[] = new int[]{1,2,3};", "int array[] = new int[3];"], "title": "下面那两项数组初始化语句是正确的?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nBuilder自己拼接自己然后输出一个局部变量，基本类型int传值引用无法修改原始值,且该方法操作为0的平方，输出为0 Hello Hello 11", "answer": "010", "content": "class Test {\n    int a1;\n\n    public static void doProduct(int a) {\n        a = a * a;\n    }\n\n    public static void doString(StringBuilder a) {\n        a.append(\" \" + a);\n    }\n\n    public static void main(String[] args) {\n        Test t1 = new Test();\n        t1.a1 = 11;\n        StringBuilder sb = new StringBuilder(\"Hello\");\n        Integer i = 0;\n        doProduct(i);\n        doString(sb);\n        doProduct(t1.a1);\n        System.out.println(i + sb.toString() + +t1.a1);\n    }\n}", "id": 59, "options": ["100 Hello Hello 121", "0 Hello Hello 11", "10 Hello Hello 121"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n全 都 错 了，原本的所有选项都出不了答案，这里改了条件让两个能正确输出了\n(注，原题为***,此处所有输出都是换行输出)", "answer": "10010", "content": "public class Test {\n    public static void main(String[] args) {\n        int x;\n        //插入代码\n    }\n}", "id": 60, "options": ["        x= 3;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x!=0);", "        x= 0;\n        do{\n            System.out.println(\"*\");\n            x++;\n        }while(x>=3);", "        x= 0;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x++<3);", "        x= 3;\n        do{\n            System.out.println(\"*\");\n            x--;\n        }while(x>0);", "        x= 0;\n        do{\n            System.out.println(\"*\");\n            ++x;\n        }while(x>1);"], "title": "请问下面哪两个代码段插入后会打印出\n*\n*\n*\n?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n看似是高贵的随机错误，实际上一看这不俩都是RuntimeException，所以实际只会输出B", "answer": "00100", "content": "class MyException extends RuntimeException{}\n\npublic class Test{\n    public static void main(String[] args){\n        try{\n            method1();\n        }catch(MyException ne){\n            System.out.println(\"A\");\n        }\n    }\n    public static void method1(){\n        try{\n            throw Math.random()>0.5?new MyException() :new RuntimeException(); // line n1\n        }catch(RuntimeException re){\n            System.out.println(\"B\");\n        }\n    }\n}", "id": 61, "options": ["在line n1处发生编译错误", "A或B", "B", "AB", "A"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n注意边界条件", "answer": "00001", "content": "public class Test {\n    public static void  main(String[] args){\n        int[] stack = {10,20,30};\n        int size = 3;\n        int idx = 0;\n        /* line n1*/\n        System.out.println(\"The Top Element:\"+stack[idx]);\n    }\n}", "id": 62, "options": ["while(idx<size){\n  idx++;\n}", "do{\n  idx++;\n}while(idx>=size);", "do{\n  idx++;\n}while(idx<=size);", "while(idx<=size-1){\n  idx++;\n}", "do{\n  idx++;\n}while(idx <size - 1);"], "title": "在line n1处插入那个代码片段能够输出\nThe Top Element:30 ?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nswitch不支持double和long", "answer": "011100", "content": "public class Test{\n    public static void main(String[] args){\n        //index n1\n        switch (x){\n            case 1:\n                System.out.println(\"One\");\n                break;\n            case 2:\n                System.out.println(\"Two\");\n                break;\n        }\n    }\n}", "id": 63, "options": ["String x = 1;", "short x = 1;", "byte x = 1;", "Integer x = new Integer(1);", "double x = 1;", "double x = 1;"], "title": "在line n1处插入哪三个代码片段可使该代码输出One?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n类型为Acc,但跨包引用实质上可访问只有公开的public s可被访问", "answer": "0010", "content": "package p1;\npublic class Acc{\n    int p;\n    private int q;\n    protected int r;\n    public int s;\n}\n\npackage p2;\n\nimport p1.Acc;\n\npublic class Test extends Acc {\n    public static void main(String[] args) {\n        Acc obj = new Test();\n    }\n}", "id": 64, "options": ["r和s都可以通过obj访问", "p和s都可以通过obj访问", "仅s可以通过obj访问", "p,r和s都可以通过obj访问"], "title": "哪项描述是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n调用父类方法和本类方法", "answer": "1000", "content": "class s1{\n    protected void display(int x){\n        System.out.println(\"Parent\"+x );\n    }\n}\nclass s2 extends s1{\n    public void display(int x,int y){\n        this.display(x);\n        display(y);\n        super.display(y);\n    }\n    public void display(int x){\n        System.out.println(\"Child\" + x);\n    }\n\n}\n\npublic class Test{\n    public static void main(String[] args){\n        s2 sobj = new s2();\n        sobj.display(10,100);\n    }\n}", "id": 65, "options": ["Child10\nChild100\nParent100", "Child10\nParent100\nParent 100", "出现一个编译错误\n", "Parent10\nChild10\nParent1000"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n静态方法只能访问静态方法和变量，而非静态方法可以自由调用静态方法和变量，但是重新初始化的对象不会保存非静态变量的值。因为静态变量的作用域独立存在，所以重复初始化仍可保留值的变化", "answer": "0001", "content": "public class StockRoom {\n    private  int stock = 10;\n    private static int qty = 0 ;\n    public void purchase(int qty) {\n        StockRoom.qty = qty;\n        stock += qty;\n    }\n\n    public void sell(int qty) {\n        StockRoom.qty = qty;\n        stock -= qty;\n    }\n    public void printStock(String action) {\n        System.out.println(action + \":\" + qty + \" items. Stock in Hand:\" + stock);\n    }\n\n    public static void main(String[] args) {\n        StockRoom k1 = new StockRoom();\n        k1.sell(5);\n        k1.printStock(\"Sold\");\n        StockRoom k2 = new StockRoom();\n        k2.purchase(5);\n        k2.printStock(\"Purchased\");\n\n    }\n}", "id": 66, "options": ["将变量Stock的方法purchase(),sell()和printStock都定义成Static.", "将变量 stock,qty和方法printStock()定义成static", "将变量stock和方法printStock()定义为static", "将变量stock定义为static."], "title": "希望打印的结果如下:\nSold: 5 items. Stock in Hand:5\nPurchased: 5 items.Stock in Hand:10\n下面哪项改变可以正确打印?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n父类不应该向下转型", "answer": "1000", "content": "public class Bird{\n    public void fly(){\n        System.out.println(\"Fly.\");\n    }\n}\npublic class Peacock extends Bird{\n    public void dance(){\n        System.out.println(\"Dance.\");\n    }\n}\npublic class Test{\n    public static void main(String[] args){\n        /*在这里插入代码*/\n        p.fly();\n        p.dance();\n    }\n}", "id": 67, "options": [" Bird b = new Peacock();\n Peacock p =(Peacock) b;", "Bird p = new Peacock();", "Peacock b = new Peacock();\nBird p = (Bird)b;", "Bird b = new Bird();\nPeacock p = (Peacock)b;"], "title": "下面哪个选项插入后会打印出\nFly.\nDance.?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n转换成父类后向下转型仍旧会编译错误,注意这题问的不是哪里会编译失败(line19向下转型会导致编译不通过)\n按抛出错误的行来说，c1向下转型成c2会更早抛出castExps", "answer": "0010", "content": "class C1 {\n}\n\nclass C2 extends C1 {\n}\n\nclass C3 extends C2 {\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        C1 obj1 = (C1) new C2();    // line 16\n        C2 obj2 = (C2) new C3();    // line 17\n        C2 obj3 = (C2) new C1();    // line 18\n        C3 obj4 = obj2;             // line 19\n    }\n}", "id": 68, "options": ["line 17", "line 16", "line 18", "line 19"], "title": "请问哪一行抛出classCastException?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n非法的日期输出会运行错误", "answer": "0010", "content": "import java.time.LocalDate;\n\npublic class Test {\n    public static void main(String[] args) {\n        LocalDate date = LocalDate.of(2012,01,32);\n        date.plusDays(10);\n        System.out.println(date);\n    }\n}", "id": 69, "options": ["2012-02-10", "编译失败", "在运行时引发DateTimeException", "2012-02-11"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n未super实现父类无参构造函数，注意子类的每个构造方法都会显式或隐式的调用父类的构造方法。\n\n即linen1处会隐式地调用无参构造函数但是父类未提供实现，且未通过super调用已存在的父类构造方法\n\nline2处 super和this方法不能在同一个构造函数内重复使用，因为他们都需要存在于一个构造函数的第一行\n\n// 关于n1更详细的解释\n首先子类确保继承成功会隐式的调用父类的构造函数，默认调用的是父类无参的构造函数\n\n但类显性定义带有参数的构造函数后，便不会自己隐形的定义无参构造函数\n\n这导致n1处调用父类无参函数失败, 需要通过super以调用父类的其余父类构造函数", "answer": "0010", "content": "class Vehicle {\n    String type = \"4w\";\n    int maxSpeed = 100;\n\n    Vehicle(String type, int maxSpeed) {\n        this.type = type;\n        this.maxSpeed = maxSpeed;\n    }\n}\n\nclass Car extends Vehicle {\n    String trans;\n\n    Car(String trans) {  //line n1\n        this.trans = trans;\n    }\n\n    Car(String type, int maxSpeed, String trans) {\n        super(type, maxSpeed);\n        this(trans); //line n2\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n\n        Car c1 = new Car(\"Auto\");\n        Car c2 = new Car(\"4w\", 150, \"Manual\");\n        System.out.println(c1.type + \" \" + c1.maxSpeed + \" \" + c1.trans);\n        System.out.println(c2.type + \" \" + c2.maxSpeed + \" \" + c2.trans);\n    }\n}", "id": 70, "options": ["编译仅在line n2处失败", "编译仅在line n1处失败", "编译仅在line n1和line n2处均失败", "null 0 Auto\n4w 150 Manual"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nfor定义的变量只能在for循环体内使用", "answer": "0010", "content": "\n\npublic class Test {\n    public static void main(String[] args) {\n\n        int sum = 0;\n        for(int xVal=1;xVal<=5;xVal++){ \n            sum =sum+xVal;\n        }\n        System.out.println(\"The sum of\"+xVal+\"number is:\"+sum);\n    \n    }\n}", "id": 71, "options": ["The num of 5 number is : 15", "The num of 5 number is : 10", "编译错误", "The num of 4 number is : 10"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没有定义无参构造方法，linen2处是在新建实例", "answer": "0001", "content": "public class Person{\n    String name;\n    int age = 25;\n    public Person(String name){\n        this(); // line n1\n        setName(name);\n    }\n    public Person(String name,int age){\n        Person(name); // line n2\n        setAge(age);\n    }\n    //setter and getter methods go here\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String show(){\n        return name+ +age;\n    }\n\n    public static void main(String[] ages){\n        Person p1 = new Person(\"Jesse\");\n        Person p2 = new Person(\"Walter\",52);\n        System.out.println(p1.show());\n        System.out.println(p2.show());\n\n\n    }\n}", "id": 72, "options": ["编译仅在line n2处失败", "Jesse 25\nWalter 52", "编译仅在line n1处失败", "编译仅在line n1和line n2处失败"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n遍历嵌套数组", "answer": "1000", "content": "\n\npublic class Test {\n    public static void main(String[] args) {\n        int[][] arr = new int[2][4];\n        arr[0] = new int[]{1, 3, 5, 7};\n        arr[1] = new int[]{1, 3};\n        for (int[] a : arr) {\n            for (int i : a) {\n                System.out.println(i + \"\");\n            }\n            System.out.println();\n        }\n    }\n}", "id": 73, "options": ["1 3 5 7\n1 3", "1 3\n 1 3 0 0", "1 3\n随后引发ArrayIndexOutOfBoundsException", "编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nindexOf找不到返回-1", "answer": "0001", "content": "\n\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sObj = new StringBuilder(\"java \");\n        System.out.println(sObj.indexOf(\"the\"));\n        sObj.append(\"the Great\");\n        System.out.println(sObj.indexOf(\"the\"));\n    }\n}", "id": 74, "options": ["false\n 6", "-1\n-1", "0\n 5", "-1\n5"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数组最后一个索引是length-1，注意边界条件\n考察细节，这里第一个循环是小于等于数组长度，故引发越界错误", "answer": "0001", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        String[][] chs = new String[2][];\n        chs[0] = new String[2];\n        chs[1] = new String[2];\n        int i = 97;\n\n        for (int a = 0; a <= chs.length; a++) {\n            for (int b = 0; b < chs.length; b++) {\n                chs[a][b] = \"\" + i;\n            }\n        }\n        for (String[] ca : chs) {\n            for (String c : ca) {\n                System.out.println(c + \"\");\n            }\n            System.out.println();\n        }\n    }\n}", "id": 75, "options": ["97\n97\n\n97\n97", "a\na\n\na\na", "编译错误", "运行引发越界错误"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n传入的是日期字符串，转换的是时间DATE_TIME(不包含小时分钟等无法正确转换)此模式可用于格式化ISO-8601日期时间字符串，但不能用于格式化日期字符串。", "answer": "0001", "content": "import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class Test {\n    public static void main(String[] args){\n        String date = LocalDate.parse(\"2014-05-04\").format(DateTimeFormatter.ISO_DATE_TIME);\n        System.out.println(date);\n    }\n}", "id": 76, "options": ["5/4/14T00:00:00.000", "2014-05-04T00:00:00.000", "May 04,2014T00:00:00.000", "在运行时抛出异常错误"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n布尔值或判断||要两边是布尔值类型，switch case判断后应及时break跳出循环避免往下继续判断(除非连续条件)", "answer": "0100", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        String grade = \"B\";\n        if (grade == \"A\" || grade == \"1\") {\n            System.out.println(\"First Grade\");\n        } else if (grade == \"B\") {\n            System.out.println(\"Second Grade\");\n        } else {\n            System.out.println(\"Third Grade\");\n        }\n    }\n}", "id": 77, "options": ["switch(grade){\n  case \"A\":\n  case \"1\":\n    System.out.println(\"First Grade\");\n    break;\n  case \"B\":\n    System.out.println(\"Second Grade\");\n    break;\n}\nSystem.out.println(\"Third Grade\");", " switch (grade) {\n   case \"A\":\n   case \"1\":\n     System.out.println(\"First Grade\");\n     break;\n   case \"B\":\n     System.out.println(\"Second Grade\");\n     break;\n   default:\n     System.out.println(\"Third Grade\");\n }", " switch(grade){\n   case \"A\": case \"1\":\n     System.out.println(\"First Grade\");\n   case \"B\":\n     System.out.println(\"Second Grade\");\n   default:\n     System.out.println(\"Third Grade\");\n\n }", "switch(grade){\n  case \"A\" || \"1\":\n    System.out.println(\"First Grade\");\n  case \"B\":\n    System.out.println(\"Second Grade\");\n  default:\n    System.out.println(\"Third Grade\");\n\n}"], "title": "下面哪项Switch语句重构if/else语句正确,并且打印出Second Grade?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n注意循环边界条件，此处只要求输出一条 D选项在执行完一次后再自增x结束循环", "answer": "0001", "content": "\npublic class Test {\n    public static void main(String[] args){\n        int x;\n        /*insert code here*/\n    }\n}", "id": 78, "options": ["x=100;\nwhile (x<=100){\n  x++;\n  System.out.println(\"Welcome\" +x);\n}", "for(x=0;x<100;++x){\n  System.out.println(\"Welcome\" +x);\n}", "for(x=0;x<=100;++x){\n  System.out.println(\"Welcome\" +x);\n}", "for (x = 100; x <= 100; x++) {\n  System.out.println(\"Welcome \" + x);\n}"], "title": "请问下面哪个代码可打印:Welcome 100?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n没传参数长度为0", "answer": "0010", "content": "public class Test {\n    public static final int MIN = 1;\n\n    public static void main(String[] args) {\n        int x = args.length;\n        if (checkLimit(x)) { //line n1\n            System.out.println(\"Java SE\");\n        } else {\n            System.out.println(\"Java EE\");\n        }\n    }\n\n    public static boolean checkLimit(int x) {\n        return (x >= MIN) ? true : false;\n    }\n}", "id": 79, "options": ["Java SE", "编译在line n1处失败", "Java EE", "在运行时引发NullPointerException"], "title": "假定运行以下命令:\njavac Test.java\njava Test\n结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n一个构造函数中 super和this只能同时用一个", "answer": "0100", "content": "class Vehicle{\n    int x;\n    Vehicle(){\n        this(10); //line n1;\n    }\n    Vehicle(int x){\n        this.x = x;\n    }\n}\nclass Car extends Vehicle{\n    int y;\n    Car(){\n        super();\n        this(20); //line n2\n    }\n    Car(int y){\n        this.y = y;\n    }\n    public String toString(){\n        return super.x+ \":\" + this.y;\n    }\n}\npublic class Test {\n\n    public static void main(String[] args) {\n        Vehicle y = new Car();\n        System.out.println(y);\n    }\n\n}", "id": 80, "options": ["编译在line n1处失败", "编译在line n2处失败", "10:20", "0:20"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n封装指将字段私有修饰并提供公开方法以获取修改", "answer": "001010", "content": "public class Customer{\n    public String name;\n    public Account account;\n\n}\npublic class Account{}", "id": 81, "options": ["定义了Account类为private", "利用构造函数初始化name和account属性", "定义name和account属性为private", "为name和account属性创建了private final setter和private getter方法", "为name和account属性创建了public setter 和public getter方法", "定义name属性为private 并且定义account属性为final"], "title": "请问哪两个动作封装了Customer类?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n构造函数内可初始值", "answer": "1100", "content": "public class Employee{\n    String name;\n    boolean contract;\n    double salary;\n    Employee(){\n        //line n1\n    }\n    public String toString(){\n        return name+\":\"+contract+\"：\"+salary;\n    }\n    public static void main(String[] args){\n        Employee e = new Employee();\n        //line n2\n        System.out.println(e);\n    }\n\n}", "id": 82, "options": ["将line  n1替换为\nthis.name = new String(\"Joe\");\nthis.contract = new Boolean(true);\nthis.salary = new Double(100);", "将line  n1替换为\nname = \"Joe\";\ncontract = true;\nsalary = 100;", "将line n1替换为\nthis(\"Joe\",true,100);", "将line n2替换为\n\n        name = \"Joe\";\n        contract = true;\n        salary = 100;"], "title": "单独进行那两项修改可使该代码输出Joe:true:100.0?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ndoStuff中将类中局部变量中的值赋值给形式参数，这不会改变局部变量，所以m2的y是整形的默认值0", "answer": "0001", "content": "public class MyField{\n    int x;\n    int y;\n    public void doStuff(int x,int y){\n        this.x= x;\n        y = this.y;\n    }\n    public void display(){\n        System.out.println(x+\" \"+y+ \":\");\n    }\n    public static void main(String[] args){\n        MyField m1 = new MyField();\n        m1.x = 100;\n        m1.y = 200;\n        MyField m2 = new MyField();\n        m2.doStuff(m1.x,m1.y);\n        m1.display();\n        m2.display();\n\n    }\n}", "id": 83, "options": ["100 0 :\n100 0 :", "100 0:\n100 200 :", "100 200 :\n100 200;", "100 200:\n100 0;"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\ns1的引用指向了s3，s3的引用指向了s2，s2指向null然后这条引用链上就全为null了，那么三个对象都符合垃圾收集条件了", "answer": "0100", "content": "\nclass Student{\n    String name;\n    int age;\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        Student s2 = new Student(); // line 11\n        Student s3 = new Student();\n        s1 = s3;\n        s3 = s2;\n        s2 = null;\n    }\n\n}", "id": 84, "options": ["在第11行后,一个对象符合垃圾收集条件", "在第11行后，三个对象符合垃圾收集条件", "在第11行后,两个对象符合垃圾收集条件", "在第11行后,没有任何对象符合垃圾收集条件"], "title": "哪项描述是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n静态方法main内调用的方法也需要是静态方法", "answer": "0100", "content": "public class Test{\n    public static void main(String[] args){\n        int numbers[] = {12,13,42,32,15,156,23,51,12};\n        int max = findMax(numbers);\n    }\n    /*line n1*/{\n        int max = 0;\n        /* code goes here */\n        return max;\n\n    }\n}", "id": 85, "options": ["static int[] findMax(int max)", "static int findMax(int[] numbers)", "public int findMax(int[] numbers)", "final int findMax(int[])"], "title": "在line n1处使用那个方法签名是正确的?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nfinal修饰的字段需要初始化一个值(定义一个修改不了的空值没有意义)，因为意味着不可修改。\n而可拓展的抽象类是不应该加上不可修改的final修饰符的。", "answer": "1010", "content": "//", "id": 86, "options": ["class A4{\n    protected static final int i;\n    private void doStuff(){}\n}", "final class A1{\n    public A1(){}\n}", "final abstract class A5{\n    protected static int i;\n    void dostuff(){}\n    abstract void doIt();\n}", "public class A2{\n    private static int i;\n    private A2(){}\n}"], "title": "哪两个类定义会编译失败?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nabstract字段修饰的抽象方法不应该有方法体，有效指的是有实际意义，封装一个私有的构造函数(且名字不同于定义的类)在这里明显是不合法的", "answer": "11100", "content": "abstract class Toy{\n    int price;\n    //line n1\n}", "id": 87, "options": ["public abstract int computeDiscount();", "public int calculatePrice(){\n        return price;\n    }", "public static void insertToy(){\n        /* code goes here*/\n    }", "private A2(){}", "public abstract Toy getToy(){\n        return new Toy();\n    }"], "title": "那三个代码片段在line n1处有效? ", "type": 1}, {"analysis": "\n\nerror和exception同级，看名字就知道不会是runTimeExps子类，可以被重复抛出", "answer": "10010", "content": "//", "id": 88, "options": ["它会在编译时期被检测", "它是RuntimeException的子类", "他不能被再次throw", "它必须用try-catch块或者被throw定义处理", "它是error的父类"], "title": "下面那两项关于可以被检测的exception 是正确的? ", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n面对对象的四大特性是 抽象、封装、继承、多态\n此处数据抽象指忽略数据细节只关注主要数据\n数据隐藏应指封装，屏蔽细节只提供操作接口\n(原答案是数据隐藏和数据验证 存疑)", "answer": "01100", "content": "//", "id": 89, "options": ["编译时期多态", "数据隐藏", "数据抽象化", "内存数据优化", "数据验证"], "title": "请问关于Java application类封装的2个特性是什么?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\njvm是java虚拟机，有java虚拟机就可以在不同平台上运行相同的字节码文件", "answer": "0100", "content": "//", "id": 90, "options": [".java文件", "JVM", "JDK", ".class文件"], "title": "下面哪个组件使得java应用程序独立于平台? ", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n基本程序结构(", "answer": "00011", "content": "public class Test{\n//line n1\n}", "id": 91, "options": ["package p1;", "for(int iVal=0;iVal<=5;iVal++){}", "import java.io.*;", "String str =\"java\";", "Test(){}"], "title": "下面那两项可以插入line n1?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\np未初始化默认值null", "answer": "0001", "content": "class Cart {\n    Product p;\n    double totalAmount;\n}\n\nclass Product {\n    String name;\n    Double price;\n}\n\npublic class Shop {\n    public static void main(String[] args) {\n        Cart c = new Cart();\n        System.out.println(c.p + \":\" + c.totalAmount);\n    }\n}", "id": 92, "options": ["null:null", "null:null:0.0", "<<HashCode>>:0.0", "null:0.0"], "title": "请问结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n重载不同方法，一般都是走默认方法即String[] args(优先级最高)，执行顺序一般之后是 char charcter int integer ", "answer": "00010", "content": "public class Maintest {\n    public static void main(int[] args) {\n        System.out.println(\"int main\" + args[0]);\n    }\n    public static void main(Object[] args) {\n        System.out.println(\"Object main\" + args[0]);\n    }\n    public static void main(String[] args) {\n        System.out.println(\"String main\" + args[0]);\n    }\n}", "id": 93, "options": ["Object main1", "int main1", "编译失败", "String main1", "在运行时引发异常错误"], "title": "运行以下命令：\njavac Maintest.java\njava Maintest 1 2 3\n结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nimport static 是静态导入，导入相应的静态字段和静态方法，这里调用后就可以直接使用(具体的代码细节不管) 此处getColor明显是个静态方法所以导入相应包后可以直接通过类名调用。而另一个选项则是获取当前包下所有类以获取某个类的静态方法。\n", "answer": "10100", "content": "package clothing.pants;\n// line n1\npublic class Jeans {\n    public void matchShirt(){\n        // line n2\n        if (color.equals(\"Green\")) {\n            System.out.println(\"Fit\");\n        }\n    }\n    public static void main(String[] args) {\n        Jeans trouser = new Jeans();\n        trouser.matchShirt();\n    }\n}", "id": 94, "options": ["在line n1处插入：import static clothing.Shirt.getColor;\n在line n2处插入：String color = getColor();", "在line n1处插入：import clothing.Shirt;\n在line n2处插入：String color = getColor();", "在line n1处插入：import clothing.*;\n在line n2处插入：String color = Shirt.getColor();", "在line n1处插入：import clothing;\n在line n2处插入：String color = Shirt.getColor();", "在line n2处插入：String color = Shirt.getColor();"], "title": "单独进行哪两组操作可使该代码片段输出Fit?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n在if语句块内初始化外部area赋值时调用不到，就被默认当成引用main内的局部变量然后出现未初始值的编译错误\n", "answer": "0001", "content": "public class Triangle {\n    static double area;\n    int b = 2, h = 3;\n    public static void main(String[] args) {\n        double p, b, h; // line n1\n        if (area == 0) {\n            b = 3;\n            h = 4;\n            p = 0.5;\n        }\n        area = p * b * h; // line n2\n        System.out.println(\"Area is \" + area);\n    }\n}", "id": 95, "options": ["Area is 3.0", "Area is 6.0", "编译在line n1处失败。", "编译在line n2处失败。"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nString默认值就是null，未设置值的String数组默认值也一样是null\n", "answer": "10000", "content": "public class Test{\n    public static void main(String[] args) {\n        String[][] chs = new String[2][];\n        chs[0] = new String[2];\n        chs[1] = new String[5];\n        int i = 97;\n        for (int a = 0; a < chs.length; a++) {\n            for (int b = 0; b < chs.length; b++) {\n                chs[a][b] = \"\" + i;\n                i++;\n            }\n        }\n        for (String[] ca : chs) {\n            for (String c : ca) {\n                System.out.print(c + \" \");\n            }\n            System.out.println();\n        }\n    }\n}", "id": 96, "options": ["97 98 \n99 100 null null null", "97 98 \n99 100 101 102 103", "在运行时引发NullPointerException", "编译失败", "在运行时引发ArrayIndexOutofBoundsException"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\nthis在构造函数中需要放在第一行，this调用构造函数时不能使用this调取实例内变量，会造成二义性(应该)", "answer": "0011", "content": "public class Shape {\n    int m;\n    int l;\n\n    //line n1\n    public Shape() {\n        this.l = 100;\n        this.m = 100;\n    }\n\n    public Shape(int l, int m) {\n        this.l = l;\n        this.m = m;\n    }\n\n    public void print() {\n        System.out.print(l + \" : \" + m);\n    }\n\n    public static void main(String[] args) {\n        Shape sh = new Shape(1000);\n        sh.print();\n    }\n}", "id": 97, "options": ["    public Shape(int m) {\n        this.l = 100;\n        this(this.l, this.m);\n    }", "public Shape(int m) {\n    this.m = m;\n    this(100, this.m);\n}", "public Shape(int m) {\n    this(100, m);\n}", "public Shape(int m) {\n    this();\n    this.l = 100;\n    this.m = m;\n}"], "title": "下面在line n1处哪俩个构造器定义可以打印出100 : 1000?", "type": 1}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n数值等类型是不能直接强转字符串类型的，一般通过拼接字符串来转型或者String.valueOf()", "answer": "0010", "content": "public class Test{\n    public static void main(String[] args) {\n        Short s1 = 200;\n        Integer s2 = 400;\n        Long s3 = (long) s1 + s2; // line n1\n        String s4 = (String) (s3 * s2); // line n2\n        System.out.println(\"Sum is \" + s4);\n    }\n}", "id": 98, "options": ["在 line n2 处引发 classCastException。", "Sum is 600", "编译在 line n2 处失败", "在 line n1 处引发 classCastException。"], "title": "结果是什么?", "type": 0}, {"analysis": "*注意，代码已经被整理为大致可运行的情况，不一定为原题意。\n\n明目张胆的越界错误，数组下标范围是0到length-1\n\n我也不知道为什么是line 10 和 14，直接不改了", "answer": "0010", "content": "public class Test{\n    public static void main(String[] args) {\n        int[] codes = new int[5];\n        codes[1] = 10; // line 10\n        codes[2] = 20;\n        codes[3] = 30;\n        codes[4] = 40;\n        codes[5] = 50; // line 14\n        for (int i = 1; i < codes.length; i++) {\n            System.out.println(codes[i] + \" : \");\n        }\n    }\n}", "id": 99, "options": ["10 : 20 : 30 : 40 : 50 :", "代码出现编译错误.", "在line 14抛出ArrayIndexOfBoundsException.", "在line 10抛出ArrayIndexOfBoundsException."], "title": "结果是什么?", "type": 0}, {"analysis": "将抛出的错误继续向上抛出，以及在执行时使用try catch捕获。CE", "answer": "00101", "content": "\n\n\nclass X {\n    public void printFileContent() {\n        /* code goes here */\n        throw new IOException(); \n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        X xobj = new X();\n        xobj.printFileContent();\n    }\n}", "id": 100, "options": ["将第 7 行替换为 throw IOException(\"Exception raised\");", "将第 11 行替换为 public static void main(String[] args)", "将第 5 行替换为 public void printFileContent() throws IOException{}", "在第 14 行，插入 throw new IOException();", "将第 13 行替换为：\ntry{\nxobj.printFileContent();\n}catch(Exception e){}"], "title": "要使该代码成功编译，应进行哪两项修改", "type": 1}, {"analysis": "indexOf内部调用equals方法，会比较查找对象和检查对象的地址，所以通过new新建的对象和已经添加的对象尽管内部属性一致也无法查找得到。所以只能返回值不是-1的只能是传入地址一致的——即原先添加的元素p2.", "answer": "0010", "content": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Test {\n\n    public static void main(String[] args) {\n        List ps = new ArrayList();\n        patient p2 = new patient(\"Mike\");\n        ps.add(p2);\n\n\n        // insert code here\n        if (f >= 0) {\n            System.out.print(\"Mike Found\");\n        }\n    }\n}\n\nclass patient {\n    String name;\n\n    public patient(String name) {\n        this.name = name;\n    }\n}", "id": 101, "options": ["int f=ps.indexOf(new patient(\"Mike Found\"));", "patient p=new patient(\"Mike\");\nint f=ps.indexOf(p);", "int f=ps.indexOf(p2);", "int f=ps.indexOf(patient(\"Mike\"));"], "title": "在第 14 行插入哪个代码片段可使代码输出 Mike Found?", "type": 0}, {"analysis": "在Java中，静态变量是类级别的变量，它会在类加载时进行初始化，并且只存在于内存中的一份拷贝。因此，无论创建多少个实例对象，这些实例对象都会共享同一个静态变量的值，因为它们都指向同一个内存地址。\n\n对象的多个实例共享同一个静态变量值", "answer": "1000", "content": "public class Test {\n    static int count = 0;\n    int i = 0;\n\n    public void changeCount() {\n        while (i < 5) {\n            i++;\n            count++;\n        }\n    }\n\n    public static void main(String[] args) {\n        Test check1 = new Test();\n        Test check2 = new Test();\n        check1.changeCount();\n        check2.changeCount();\n        System.out.println(check1.count + \" : \" + check2.count);\n    }\n}", "id": 102, "options": ["10 : 10", "编译失败", " 5 : 5", "5 : 10"], "title": "结果是什么?", "type": 0}, {"analysis": "向下转型需要强制转换，所以E直接double向下转型会编译错误。\n因为double精度比float高，直接转型会损失精度。\n", "answer": "00001", "content": "// 看选项", "id": 103, "options": ["float fit = 100;", "float fit = (float) 1_11.00;", "float fit = 100F;", "int y2 = 100;\nfloat fit = (float) y2;", "double y1 = 203.22;\nfloat fit = y1;"], "title": "哪个代码片段会导致编译错误？", "type": 0}, {"analysis": "由于多态允许在运行时根据实际情况执行不同的方法，因此它可以使代码更具有通用性、灵活性。\n\n且由于对象的实际类型只有在程序运行时才能确定，因此多态使得程序能够在不同的条件下运行不同的代码，从而使其更具有动态性和灵活性。\n\n故多态性优点为AB, 灵活动态", "answer": "11000", "content": "// 插入代码", "id": 104, "options": ["代码的灵活性和可用性更高", "在运行时代码动态性更高", "在运行时代码效率更高", "当值代码被其他类扩展使用", "在运行时代码速度快"], "title": "哪两项是多态性的优点？", "type": 1}, {"analysis": "静态方法内只能调用静态变量，由于静态方法不依赖于类的实例，因此不能直接访问非静态成员变量。C", "answer": "0010", "content": "public class App {\n    int count; // line n1\n    public static void display() { // line n2\n        count++; // line n3\n        System.out.println(\"Welcome \" + \"Visit count: \" + count); // line n4\n    }\n\n    public static void main(String[] args) {\n        App.display();\n        App.display();\n    }\n}", "id": 105, "options": ["Welcome Visit count: 1\nWelcome Visit count: 1", "编译 line n1 和 line n2 处失败", "编译 line n3 和 line n4 处失败", "Welcome Visit count: 1\nWelcome Visit count: 2"], "title": "结果是什么？", "type": 0}, {"analysis": "除数为0，会检测到算数错误使ans=0", "answer": "00100", "content": "public class Test {\n\n    public static void main(String[] args) {\n        int ans = 0;\n        try {\n            int num = 10;\n            int div = 0;\n            ans = num / div;\n        } catch (ArithmeticException ae) {\n            // TODO: handle exception\n            ans = 0; // line n1\n        } catch (Exception e) {\n            // TODO: handle exception\n            System.out.println(\"Invalid calculation\");\n        }\n        System.out.println(\"Answer =\" + ans);// line n2\n    }\n}", "id": 106, "options": ["Invalid calculation", "linen1 linen2处编译失败", "Answer = 0", "仅在linen1处编译失败", "仅在linen2处编译失败"], "title": "结果是什么 ?", "type": 0}, {"analysis": "//原题是println,改成了print方便选项显示\n注意边界条件", "answer": "0010", "content": "public class Test {\n\n    public static void main(String[] args) {\n        int ii = 0;\n        int jj = 7;\n        for (ii = 0; ii < jj - 1; ii = ii + 2) {\n            System.out.print(ii + \" \");\n        }\n    }\n}", "id": 107, "options": ["编译失败", "2 4", "0 2 4", "0 2 4 6"], "title": "结果是什么？", "type": 0}, {"analysis": "A) 子类可以从超类继承，这是 Java 语言中面向对象编程的核心特性之一，通过继承，子类可以重用超类的属性和方法，从而避免了代码重复和提高了代码的可维护性。\n\nE) 对象之间可以共享行为，这是 Java 语言中面向对象编程的另一个核心特性。在 Java 中，对象可以相互交互并共享行为，这样就可以让对象之间实现紧密的协作，从而提高程序的可扩展性和可重用性。\n\nF) Object 是所有其他对象的根类，这是 Java 语言中非常重要的概念。", "answer": "100011", "content": "// 插入代码", "id": 108, "options": ["子类可以从超类继承。", "必须在每个类中声明一个 main 方法。", "不能重用对象。", "一个程序包必须包含多个类。", "对象之间可以共享行为。", "Object 是所有其他对象的根类"], "title": "哪三项描述了 Java 语言的面向对象功能？", "type": 1}, {"analysis": "调用忽略大小写的equals以比较相同的string值。", "answer": "0010", "content": "public class App {\n    public static void main(String[] args) {\n        String str1 = \"Java\";\n        String str2 = new String(\"java\");\n        // line n1\n        {\n            System.out.println(\"Equal\");\n        } else {\n            System.out.println(\"Not Equal\");\n        }\n    }\n}", "id": 109, "options": ["String str3 = str2;\nif ( str1.equals (str3) )", "if(str1.toLowerCase() == str2. toLowerCase())", "if(str1.equalsIgnoreCase(str2))", "String str3 = str2;\nif(str1 == str3)"], "title": "在 line n1 处插入哪个片段可使 App 类输出 Equal ?", "type": 0}, {"analysis": "遍历二维数组赋值，数组长度为1*3", "answer": "0001", "content": "public class Test {\n\n    public static void main(String[] args) {\n        int num[][] = new int[1][3];\n        for (int i = 0; i < num.length; i++) {\n            for (int j = 0; j < num[i].length; j++) {\n                num[i][j] = 10;\n            }\n        }\n    }\n}", "id": 110, "options": ["num[0][0]=10;\nnum[0][1]=0;\nnum[0][2]=0;", "num[0][0]=10;\nnum[1][0]=10;\nnum[2][0]=10;", " num[0][0]=10;\n num[0][1]=10;\n num[0][2]=10;\n num[0][3]=10;\n num[1][0]=0;\n num[1][1]=0;\n num[1][2]=0;\n num[1][3]=0", " num[0][0]=10;\n num[0][1]=10;\n num[0][2]=10;"], "title": "哪个选项表示成功完成外部循环后 num 数组的状态？", "type": 0}, {"analysis": "if判断后面有个分号，实际上是循环第一个之后就break打断循环。所以A D", "answer": "0001", "content": "public class Test {\n\n    public static void main(String[] args) {\n        String[][] arr = { { \"A\", \"B\", \"C\" }, { \"D\", \"E\" } };\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n                if (arr[i][j].equals(\"B\"));\n                {\n                    break;\n                }\n            }\n            continue;\n        }\n    }\n}", "id": 111, "options": ["编译失败。", "A B C", "A B C D E", "A D"], "title": "结果是什么?", "type": 0}, {"analysis": "// 这个选项看起来是机翻的\n扩展此处指的是通过泛型类继承，因为错误捕获需要获取准确的错误类型以使其进入正确的catch分支。而泛型类在使用中会擦除泛型导致无法区分准确错误类型\n\n此处不可扩展的应为Exception 和 Throwable 类，原因是泛型类和接口中使用的类型参数会在编译时被擦除，而 Exception 和 Throwable 的类型信息则需要在运行时被保留，以便进行异常处理。B)错误\n\n关于 D) 和 E)，它们都是错误的描述。Error 不属于 RuntimeException，因为它们都不是基于 RuntimeException 的子类。而 Error 也不属于 Exception，因为它们都不是基于 Exception 的子类。\n\n可引发可理解为执行过程中会被抛出的异常\n", "answer": "10100", "content": "// 看选项", "id": 112, "options": ["Error 类可扩展", "Error 类不可扩展", "Error 可引发", "Error 属于 RuntimeException。", "Error 属于 Exception"], "title": "哪两项描述是正确的?", "type": 1}, {"analysis": "A 简单考察数组初始化语句", "answer": "1000", "content": "\npublic class Test {\n    \n    public static void main(String[] args) {\n        /* insert code here */\n        array[0] = 10;\n        array[1] = 20;\n        System.out.print(array[0] + \":\" + array[1]);\n    }\n}", "id": 113, "options": ["int[] array = new int[2];", "int[] array;\narray = int[2];", "int array[2];", "int array = new int[2];"], "title": "在第 5 行插入哪个代码片段可使该代码输出 10:20?", "type": 0}, {"analysis": "//原答案是AEF, 但A选项调用了未定义的acct变量，想了想还是改成了BEF", "answer": "010011", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        CheckingAccount acct = new CheckingAccount();\n        // line n2\n    }\n}\n\n// CheckingAccount.java\npublic class CheckingAccount {\n    public int amount;\n    // line n1\n}\n", "id": 114, "options": ["line n1 处插入：\npublic CheckingAccount(){\n\tacct.amount = 100;\n}", " line n1 处插入：\npublic CheckingAccount(){\n\tthis.amount = 100;\n}", "line n2 处插入：\nthis.amount = 100;", "line n2 处插入：\namount = 100;", "line n2 处插入：\nacct.amount = 100;", "line n1 处插入：\npublic CheckingAccount(){\n\tamount = 100;\n}"], "title": "单独插入哪三段代码可以将 amount 值设置为 100？", "type": 1}, {"analysis": "原Employee.java缺失了相关方法和变量定义，但是很明显this方法应该在构造函数第一行，所以会编译错误。\n\n如果没有定义任何构造函数，Java会自动提供一个默认的无参构造函数。但是一旦你显式地定义了任何一个构造函数（无参或带参），Java就不会再提供默认的无参构造函数了。这时，如果想要调用无参构造函数，就要自己定义并实现。\n\n所以Test.java调用无参构造函数失败", "answer": "00010", "content": "// Employee.java\npublic class Employee {\n  \t// ...variable define list\n\n    public Employee(String name, int age) {\n        this.name = name;\n        this.age = age;\n        this.salary = 2000;\n    }\n\n    public Employee(String name, int age, int salary) {\n        setSalary(salary);\n        this(name,age);\n    }\n\n    // getter and setter methods for attributes go here\n\n    public void printDetails() {\n        System.out.println(name + \":\" + age + \":\" + salary);\n    }\n}\n// Test.java\n\npublic class Test {\n\n     public static void main(String[] args) {\n        Emoployee e1 = new Employee();\n        Emoployee e2 = new Employee(\"Jack\", 50);\n        Emoployee e3 = new Employee(\"Chloe\", 40, 5000);\n        e1.printDetails();\n        e2.printDetails();\n        e3.printDetails();\n    }\n}\n", "id": 115, "options": ["编译在 Test 类中失败", "null:0:0\n Jack:50:0\n Chloe:40:5000", "编译在 Employee 类中失败", "Employee 类和 Test 类都编译失败", "null : 0 : 0;\n Jack : 50 : 2000;\n Chole : 40 : 5000"], "title": "结果是什么?", "type": 0}, {"analysis": "原答案是编译失败(难道是因为原题语句后面没有分号)\n此处注意remove方法可重载，调用remove(2)就是删除索引2，调用remove(null)就是删除空对象即可，就是说能正常执行输出", "answer": "001000", "content": "import java.util.ArrayList;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        ArrayList<Integer> points = new ArrayList<>();\n        points.add(1);\n        points.add(1);\n        points.add(1);\n        points.add(1);\n        points.add(1);\n        points.remove(2);\n        points.remove(null);\n        System.out.println(points);\n\n    }\n}\n", "id": 116, "options": ["[1,3,4,null]", "[1,2,4]", "\n[1,1,1,1]", "\n[1,2,4,null]", "\n[1,3,4]", "\n在执行时引发 NullpointerExcoption"], "title": "结果是什么?", "type": 0}, {"analysis": "新建空数组，String是对象，默认初始值为null，所以调用concat方法会报错", "answer": "0100", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        String[] strs = new String[2];\n        int idx = 0;\n        for (String s : strs) {\n            strs[idx].concat(\" element \" + idx);\n            idx++;\n        }\n        for (idx = 0; idx < strs.length; idx++) {\n            System.out.println(strs[idx]);\n        }\n\n    }\n}\n", "id": 117, "options": ["element 0\nelement 1", "在运行时引发 NullpointerExcoption", "null element0\nnull element1", "Null\nNull"], "title": "结果是什么?", "type": 0}, {"analysis": "line n2尝试将 b2 强制类型转换为 B 类型。但是，实际上 b2 引用的对象是 C 类的实例，而 C 类不是 B 类的子类(他们是兄弟关系)。\n\n由于 C 类不能强制转换为 B 类，所以会抛出 ClassCastException 异常。\n答案是D", "answer": "00010", "content": "public class C extends A {\n    public void test() {\n        System.out.println(\"C \");\n    }\n\n    public static void main(String[] args) {\n        A b1 = new A();\n        A b2 = new C();\n        b1 = (A) b2; // line n1\n        A b3 = (B) b2; // line n2\n        b1.test();\n        b3.test();\n    }\n}\nclass A {\n    public void test() {\n        System.out.println(\"A \");\n    }\n}\n\nclass B extends A {\n    public void test() {\n        System.out.println(\"B \");\n    }\n}", "id": 118, "options": ["仅在 line n1 处引发 ClassCastException", " C\n C", " A\n C", "仅在 line n2 处引发 ClassCastException", "A\nB"], "title": "结果是什么?", "type": 0}, {"analysis": "要求有抽象方法，B选项抽象方法不应该有方法体所以错误\nAC选项没有抽象方法所以错误", "answer": "0001", "content": "// 看选项", "id": 119, "options": ["public abstract class Toy {\n    public int calculatePrice(Toy t);\n    public final void printToy(Toy t) { /* code goes here */ }\n}\n", "public abstract class Toy {\n    public abstract int calculatePrice(Toy t) { /* code goes here */ }\n    public abstract void printToy(Toy t) { /* code goes here */ }\n}\n", "public abstract class Toy {\n    public int calculatePrice(Toy t);\n    public void printToy (Toy t);\n}\n", "public abstract class Toy {\n    public abstract int calculatePrice(Toy t);\n    public void printToy (Toy t) { /* code goes here */ }\n}\n"], "title": "要求您为一个购物应用程序开发程序，并为您提供了以下信息：\n●该应用程序必须包含类 Toy、 EduToy 和 ConsOy。Toy 是其他两个类的超类(父类)\n●int calculatePrice(Toy t)方法计算玩具的价格。\n●void printToy(Toy t)方法输出玩具的详细信息。\n哪个 Toy 类定义会向类层次结构添加有效的抽象层？", "type": 0}, {"analysis": "LocalDateTime类中的日期和时间对象是不可变的。在执行plusDays()和plusMonths()方法时，它们不会修改dt变量本身的值，而是返回一个新的LocalDateTime对象\n所以输出内容不变 A", "answer": "1000", "content": "import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        LocalDateTime dt = LocalDateTime.of(2014, 7, 31, 1, 1);\n        dt.plusDays(30);\n        dt.plusMonths(1);\n        System.out.println(dt.format(DateTimeFormatter.ISO_DATE));\n\n    }\n\n}\n", "id": 120, "options": ["2014-07-31", "2014-09-30", " 07-31-2014", "在运行时引发异常错误。"], "title": "结果是什么？", "type": 0}, {"analysis": "要使amount为0，此处可以直接设为0或减去amount自身，所以可选ABF", "answer": "11000100", "content": "// CheckingAccount.java\npublic class CheckingAccount {\n    public int amount;\n\n    public CheckingAccount(int amount) {\n        this.amount = amount;\n    }\n\n    public int getAmount() {\n        return amount;\n    }\n\n    public void ChangeAccount(int x) {\n        amount += x;\n    }\n}\n// Test.java\npublic class Test {\n    public static void main(String[] args){\n        CheckingAccount acct= new CheckingAccount((int)(Math.random()*1000));\n        //line nl\n        System.out.println(acct.getAmount());\n    }\n}\n", "id": 121, "options": ["acct.ChangeAmount(-acct.amount)", "acct.ChangeAmount(-acct.getAmount());", "acct.getAmount()=0;", "acct.ChangeAmount(0);", "acct(0);", "acct.amount=0;", "amount=0;", "this.amount=0;"], "title": "在 line nl 处单独插入哪三行可使程序输出 0 余额？", "type": 1}, {"analysis": "trim()方法返回去除开头和结尾部分的空格的字符串，\" abc   \".trim() -> \"abc\";\n这里没有重新赋值，所以不会保存修改(事实上也没有修改)\n然后i1是第一个空格，从0开始计数所以返回5", "answer": "0010", "content": "public class Test {\n    public static void main(String[] args) {\n        String myStr = \"Hello Word\";\n        myStr.trim();\n        int i1 = myStr.indexOf(\" \");\n        System.out.println(i1);\n    }\n}\n", "id": 122, "options": ["在运行时引发异常错误", "-1", "5", "0"], "title": "结果是什么?", "type": 0}, {"analysis": "一旦确定了匹配的case，就会执行相应的代码块，不会在运行时修改case标签的值。\n\nBC都不是必须", "answer": "0001", "content": "// 插入代码", "id": 123, "options": ["在运行时可以修改 case 标签的值", "它必须包含 default 部分", "每个 case 块结尾处必须有 break", "其表达式的求值结果必须为单个值"], "title": "关于 switch 语句，哪项描述是正确的？", "type": 0}, {"analysis": "从左到右计算拼接字符串，且表达式计算未用括号提高优先级", "answer": "0010", "content": "public class Test {\n    public static void main(String[] args){\n        System.out.println(\"Result A \" + 0 + 1);\n        System.out.println(\"Result B \" + (1) + (2));\n    }\n}\n", "id": 124, "options": ["Result A 1\nResult B 12", "Result A 1\nResult B 3", "Result A 01\nResult B 12", "Result A 01\nResult B 3"], "title": "结果是什么?", "type": 0}, {"analysis": "抽象类Book可以选择性实现接口中的方法\n而未被实现的方法对于非抽象类EBook来说是必须要实现的,所以B可通过编译，A只是重定义了一个抽象方法，依旧未在EB中实现，因为不能直接初始化一个抽象类所以C也错误，D则是Book中也未实现方法。", "answer": "0100", "content": "interface Readable{\n    public void readBook();\n    public void setBookMark();\n}\nabstract class Book implements Readable{ //line n1\n    public void readBook(){}\n//line n2\n}\nclass EBook extends Book{ //line n3\n    public void readBook(){}\n//line n4\n}\npublic class Test {\n    public static void main(String[] args){\n        Book book1 = new EBook();\n        book1.readBook();\n    }\n}\n", "id": 125, "options": ["在 line n2 处插入：\npublic abstract void setBookMark();", "在 line n4 处插入：\npublic void setBookMark(){}", "将 line n3 处的代码片段替换为：\nabstract class EBook extends Book{", "将 line n1 处的代码片段替换为：\nclass Book implements Readable {"], "title": "哪个选项可使该代码通过编译？", "type": 0}, {"analysis": "A: 此处未被检测的异常通常指的是运行时异常（也称为非受检异常或unchecked exception）。因为违背检测异常不需要通过try catch显示处理，所以可以自由选择在其他方法捕获抛出错误。\n\nB(错):Exception 类的所有子类（包括 RuntimeException）都被认为是已检查的异常，除非它们自己是 RuntimeException 的子类。\n\nC错误。RuntimeException 类的子类是未检查的异常，因此它们不必在方法签名中声明，也不必强制捕获或抛出。\n\nD:Throwable 类是 Java 异常层次结构中所有异常类\n\nE:Error 类及其子类表示不可恢复的严重问题，而不是已检查的异常错误。它们通常不被认为是可恢复的。\n\nF:java错误恢复指的是jvm和程序在发生错误时的一些恢复机制。主要包括: 错误捕获，重启，输出日志，修复等操作。因为RuntimeException不需要显式处理，可以在触发时自己执行回复操作。", "answer": "100101", "content": "// 看选项", "id": 126, "options": ["只有未被检测的异常可以重新抛出。", "Exception 类的所有子类(RuntimeException 类除外) 都是已检查的异常错误。", "所有 RuntimeException 类的子类必须被捕获或者抛出。", "catch 块中的参数为 Throwable 类型。", " Error 类的所有子类都是已检查的异常错误并且可恢复。", " RuntimeException 类的所有子类均可恢复。"], "title": "关于异常错误处理，哪三项描述是正确的？", "type": 1}, {"analysis": "LocalDate.parse(\"2014-06-20\", DateTimeFormatter.ISO_DATE) 方法根据给定的字符串以ISO标准格式解析日期，即\"yyyy-MM-dd\"。\n\nLocalDate 类在默认情况下使用的输出格式是 ISO-8601 标准格式，即\"yyyy-MM-dd\"", "answer": "0010", "content": "import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        LocalDate date1 = LocalDate.now();\n        LocalDate date2 = LocalDate.of(2014, 6, 20);\n        LocalDate date3 = LocalDate.parse(\"2014-06-20\", DateTimeFormatter.ISO_DATE);\n        System.out.println(\"date1 = \" + date1);\n        System.out.println(\"date2 = \" + date2);\n        System.out.println(\"date3 = \" + date3);\n    }\n\n}\n", "id": 127, "options": ["编译失败。", "在运行时引发 DateParseException。", "date1 = 2014-06-20\ndate2 = 2014-06-20\ndate3 = 2014-06-20", "date1 = 06/20/2014\ndate2 = 2014-06-20\ndate3 = Jun 20, 2014"], "title": "假定系统日期为 2014 年 6 月 20 日。\n结果是什么？", "type": 0}, {"analysis": "下标范围为[0,数组长度-1]", "answer": "00001", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        String shirts[][] = new String[2][2];\n        shirts[0][0] = \"red\";\n        shirts[0][1] = \"blue\";\n        shirts[0][2] = \"small\";\n        shirts[0][3] = \"medium\";\n    }\n\n}\n", "id": 128, "options": ["for (String c : colors) {\n  for (String s : sizes) {\n    System.out.println(s + \":\");\n  }\n}", "for (int index = 1; index < 2; index++) {\n  for (int idx = 1; idx < 2; idx++) {\n    System.out.println(shirts[index][idx] + \":\");\n  }\n}", "for (int index = 0; index < 2;) {\n  for (int idx = 1; idx < 2;) {\n    System.out.println(shirts[index][idx] + \":\");\n    idx++;\n  }\n  index++;\n}", "for (int index = 0; index < 2; ++index) {\n  for (int idx = 0; idx < index; ++idx) {\n    System.out.println(shirts[index][idx] + \":\");\n  }\n}", "抛出异常 ArrayIndexOutOfBoundsException"], "title": "哪个代码片段输出 red:blue:small:medium:?", "type": 0}, {"analysis": "输出5...1, 先输出后自减", "answer": "0001", "content": "public class Test {\n\n    public static void main(String[] args) {\n        int x = 5;\n        while (isAvailable(x)) {\n            System.out.println(x);\n\n        }\n    }\n    \n    public static boolean isAvailable(int x) {\n        return x-- > 0 ? true : false;\n    }\n\n}\n", "id": 129, "options": ["将第 12 行替换为 return (x-- > 0) ? true : false;", "将第 6 行替换 --x; 并在第 7 行插入 System.out.println(x);", "将第 6 行替换为 System.out.println(--x);", "在第 7 行插入 x--;"], "title": "哪项修改可使该代码输出 54321？", "type": 0}, {"analysis": "由于多态性的特性，编译时类型为 Base，但运行时类型为 DerivedB，所以调用的是 DerivedB 类中重写的 test() 方法，因此输出结果为 \"DerivedB DerivedB\"。", "answer": "00010", "content": "// Base.java\nclass Base {\n    public void test() {\n        System.out.print(\"Base \");\n    }\n}\n//DerivedA.java\nclass DerivedA extends Base {\n    public void test() {\n        System.out.print(\"DerivedA \");\n    }\n}\n\n//DerivedB.java\npublic class DerivedB extends DerivedA {\n    public void test() {\n        System.out.print(\"DerivedB \");\n    }\n\n    public static void main(String[] args) {\n        Base b1 = new DerivedB();\n        Base b2 = new DerivedA();\n        Base b3 = new DerivedB();\n        b1 = (Base) b3;\n        Base b4 = (DerivedA) b3;\n        b1.test();\n        b4.test();\n    }\n}\n", "id": 130, "options": [" DerivedB DerivedA", " Base DerivedB", "在运行时引发 ClassCastExcception", " DerivedB DerivedB", "Base DerivedA"], "title": "结果是什么？", "type": 0}, {"analysis": "// 修正原答案，原答案B选项仍未引入\n要求通过编译，那么B类需要引入A,B类\nC类需要引入A和B\nA选项n2处只引入了B,其他选项同理。\n选B", "answer": "0100", "content": "// A.java\npackage p1;\n\npublic class A {\n}\n// B.java\npackage p1.p2;\n// line n1\npublic class B {\n    public void doStuff() {\n        A b = new A();\n    }\n}\n// C.java\npackage p3;\n// line n2\npublic class C {\n    public static void main(String[] args) {\n        A o1 = new A();\n        B o2 = new B();\n    }\n}\n\n", "id": 131, "options": ["将 line n1 替换为:\n import p1.*;\n将 line n2 替换为:\nimport p1.p2.*;", "将 line n1 替换为:\nimport p1.A;\n将 line n2 替换为:\nimport p1.*;\nimport p1.p2.B;", "将 line n1 替换为:\nimport p1;\n将 line n2 替换为:\nimport p1.p2;", "将 line n1 替换为:\nimport p1.A;\n将 line n2 替换为:\nimport p1.p2.B;"], "title": "哪项修改可使该代码通过编译?", "type": 0}, {"analysis": "// 与原题相比有变动\n原题AB选项一样却选了B, 这里调整后确保B是唯一符合题意的", "answer": "010", "content": "public class Customer {\n    ElectricAccount acct = new ElectricAccount();\n  \n    public void useElectricity(double kWh){\n        acct.addKWh(kWh);\n    }\n}\n\npublic class ElectricAccount{\n    private double kWh;\n    private double rate = 0.07;\n    private double bill;\n    //line n1\n}\n", "id": 132, "options": ["private void addKWh(double kWh){\n    if(kWh>0){\n        this.kWh += kWh;\n        this.bill = 0; \n    }\n}\n", "public void addKWh(double kWh){\n    if(kWh>0){\n        this.kWh += kWh;\n        this.bill = this.kWh * this.rate;\n    }\n}\n", "public void addKWh(double kWh){\n    if(kWh>0){\n        this.kWh += kWh;\n        setBill(this.kWh);\n    }\n}\n"], "title": "要使成员变量 bill 始终等于成员变量 kWh 乘以变量 rate 的值,如何编写 line n1 处的\nElectricAccount 类?\n客户使用的电量(用 Customer 类的实例表示)必须通过方法 useElectricity 提供给客户的账单\n(用成员变量 bill 表示).Customer 类的实例始终不得篡改或减少成员变量 bill 的值.", "type": 0}, {"analysis": "方法重载根据传入类型，这里注意浮点数字面量类型默认是double", "answer": "1000", "content": "public class SumTest {\n    public static void doSum(Integer x, Integer y) {\n        System.out.println(\"Integer sum is \" + (x + y));\n    }\n\n    public static void doSum(double x, double y) {\n        System.out.println(\"double sum is \" + (x + y));\n    }\n\n    public static void doSum(float x, float y) {\n        System.out.println(\"float sum is \" + (x + y));\n    }\n\n    public static void doSum(int x, int y) {\n        System.out.println(\"int sum is \" + (x + y));\n    }\n\n    public static void main(String[] args) {\n        doSum(10, 20);\n        doSum(10.0, 20.0);\n    }\n}\n", "id": 133, "options": ["int sum is 30\ndouble sum is 30.0", "Integer sum is 30\ndouble sum is 30.0", "Integer sum is 30\nfloat sum is 30.0", "int sum is 30\nfloat sum is 30.0"], "title": "结果是什么?", "type": 0}, {"analysis": "注意 char 默认值为空字符'\\u0000'(可用整型0表示)，所以无输出", "answer": "0010", "content": "public class FieldInit {\n    char c;\n    boolean b;\n    float f;\n\n    void printAll() {\n        System.out.println(\"c=\" + c);\n        System.out.println(\"b=\" + b);\n        System.out.println(\"f=\" + f);\n    }\n\n    public static void main(String[] args) {\n        FieldInit f = new FieldInit();\n        f.printAll();\n    }\n}", "id": 134, "options": ["c=null;\nb=float;\nf=0.0F;", "c=null;\nb=true;\nf=0.0;", "c=;\nb=false;\nf=0.0;", "c=0;\nb=float;\nf=0.0f;"], "title": "结果是什么?", "type": 0}, {"analysis": "作为对象的obj是引用传递 obj2 接收了obj1的引用而不是新建对象，所以他们的var是同一个，都被设置为o， 而基本类型数据是传值引用(复制值)所以不会修改var2不会影响var1", "answer": "0010", "content": "public class Vowel {\n    private char var;\n\n    public static void main(String[] args) {\n        char var1 = 'a';\n        char var2 = var1;\n        var2 = 'e';\n        Vowel obj1 = new Vowel();\n        Vowel obj2 = obj1;\n        obj1.var = 'i';\n        obj2.var = 'o';\n        System.out.println(var1 + \",\" + var2);\n        System.out.print(obj1.var + \",\" + obj2.var);\n    }\n}", "id": 135, "options": ["e,e\no,o", "e,e\ni,o", "a,e\no,o", "a,e\ni,o"], "title": "结果是什么?", "type": 0}, {"analysis": "A 重载指同名方法，参数列表不同。\nB 编译器可以通过上下文自行判断代码中调用的是字段还是方法\nF java会默认隐性的初始化一个默认值，所以不必显式初始化(指全局变量)\n\n错误项:\nC 如承载数据的类就可能没有方法\nD 只有作为应用程序的入口点才需要一个main方法\nE 同重载，可以有多个私有构造方法", "answer": "110001", "content": "// 看选项", "id": 136, "options": ["一个类可以有多个重载静态方法.", "方法名称可以与字段名称相同.", "方法是类的必需组件.", "一个公共类必须有一个main方法.", "一个类只能有一个私有构造器.", "字段不需要初始化即可使用."], "title": "关于Java类的结构,哪三项描述是正确的?", "type": 1}, {"analysis": "continue语句直接进入下一次循环，导致count++无法被访问，编译器会检测该问题并导致编译失败", "answer": "0100", "content": "public class Test {\n\n    public static void main(String[] args) {\n        int data[] = { 2010, 2013, 2014, 2015, 2014 };\n        int key = 2014;\n        int count = 0;\n\n        for (int e : data) {\n            if (e != key) {\n                continue;\n                count++;\n            }\n        }\n\n        System.out.print(count + \" Found\");\n    }\n\n}\n", "id": 137, "options": ["0  Found", "编译失败", "3  Found", "1  Found"], "title": "结果是什么?", "type": 0}, {"analysis": "重新初始化时会丢弃上次初始化后保存的值，而int数组默认值为0", "answer": "0100", "content": "public class Test {\n\n    public static void main(String args[]) {\n        int numbers[];\n        numbers = new int[2];\n        numbers[0] = 10;\n        numbers[1] = 20;\n\n        numbers = new int[4];\n        numbers[2] = 30;\n        numbers[3] = 40;\n        for (int x : numbers) {\n            System.out.print(\" \" + x);\n        }\n    }\n\n}\n", "id": 138, "options": ["在运行时引发异常错误。", "0 0 30 40", "编译失败", "10 20 30 40"], "title": "结果是什么?", "type": 0}, {"analysis": "当两个类位于同一个包中时，它们的访问修饰符默认为包级访问权限，即在包内部可见。所以他们可以互相访问，而MyString没有覆盖toString方法所以默认输出哈希值地址", "answer": "0001", "content": "// MyString.java\npackage p1;\n\npublic class MyString {\n    String msg;\n\n    MyString(String msg) {\n        this.msg = msg;\n    }\n}\n\n// Test.java\npackage p1;\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello \" + new StringBuilder(\"Java SE 8\"));\n        System.out.println(\"Hello \" + new MyString(\"Java SE 8\"));\n    }\n}\n", "id": 139, "options": ["Hello JAVA SE 8\nHello JAVA SE 8", "编译在Test类处失败", "Hello java.lang.StringBuilder@<<hashcode1>>\nHello p1.MyString@<<hashcode1>>", "Hello JAVA SE 8\nHello p1.MyString@<<hashcode1>>"], "title": "结果是什么?", "type": 0}, {"analysis": "主要借助父类初始值和父类构造函数以实现设置相应值\n", "answer": "10010", "content": "class Animal {\n    String type = \"Canine\";\n    int maxSpeed = 60;\n\n    Animal() {\n    }\n\n    Animal(String type, int maxSpeed) {\n        this.type = type;\n        this.maxSpeed = maxSpeed;\n    }\n}\n\npublic class WildAnimal extends Animal {\n    String bounds;\n\n    public WildAnimal(String bounds) {\n        // line n1\n    }\n\n    public WildAnimal(String type, int maxSpeed, String bounds) {\n        // line n2\n    }\n\n    public static void main(String[] args) {\n        WildAnimal wolf = new WildAnimal(\"Long\");\n        WildAnimal tiger = new WildAnimal(\"Feline\", 80, \"Short\");\n        System.out.println(wolf.type + \" \" + wolf.maxSpeed + \" \" + wolf.bounds);\n        System.out.println(tiger.type + \" \" + tiger.maxSpeed + \" \" + tiger.bounds);\n    }\n}\n", "id": 140, "options": ["在n1处替换以下代码:\nsuper();\nthis.bounds = bounds;", "在n1处替换以下代码:\nthis(\"Canine\",60);\nthis.bounds = bounds;", "在n2处替换以下代码:\nsuper(type,maxSpeed);\nthis(bounds);", "在n2处替换以下代码:\nsuper(type,maxSpeed);\nthis.bounds = bounds;", "在n1处替换以下代码:\nthis.bounds = bounds;\nsuper();"], "title": "哪两项修改可使该代码输出以下内容\nCanine 60 Long\nFeline 80 Short?", "type": 1}, {"analysis": "只通过new创建了一个实例，赋值obj2是传递引用不是复制实例", "answer": "1000", "content": "public class MarkList {\n    int num;\n\n    public static void graceMarks(MarkList obj4) {\n       obj4.num += 10;\n    }\n\n    public static void main(String[] args) {\n        MarkList obj1 = new MarkList();\n        MarkList obj2 = obj1;\n        MarkList obj3 = null;\n        obj2.num = 60;\n        graceMarks(obj2);\n    }\n}\n", "id": 141, "options": ["1", "2", "3", "4"], "title": "在运行时内存中会创建多少个 MarkList实例？", "type": 0}, {"analysis": "通过.length方法获取StringBuilder的长度,delete清除区间范围内容\n而另外两个方法StringBuilder并没有相应api", "answer": "0100", "content": "// 看选项", "id": 142, "options": ["sb.delete(0, sb.size());", "sb.delete(0, sb.length()); ", "sb.removeAll();", "sb.deleteAll();"], "title": "哪个语句将清空名为sb的 StringBuilder変量的内容？", "type": 0}, {"analysis": "substring的endIndex可以等于字符串长度，但不能大于，所以遍历到第二个元素时会报错，直接遍历输出pwd数组", "answer": "0010", "content": "public class Test {\n\n    public static void main(String[] args) {\n        String names[] = {\"Thomas\", \"Peter\", \"Joseph\"};\n        String pwd[] = new String[3];\n        int idx = 0;\n        try {\n            for (String n : names) {\n                pwd[idx] = n.substring(2, 6);\n                idx++;\n            }\n        } catch (Exception e) {\n            System.out.println(\"Invalid Name\");\n        }\n        for (String p : pwd) {\n            System.out.println(p);\n        }\n    }\n    \n\n}\n", "id": 143, "options": ["Invalid Name", "Omas\nter\nseph", "Invalid Name  \nomas\nnull\nnull", "Invalid Name\nomas"], "title": "结果是什么?", "type": 0}, {"analysis": "增强for是声明数组元素引用而不需要控制索引遍历的循环方式\nfor(int i:arr){}\n而标准for就是传统的控制索引的遍历\nfor(int i=0;i<arr.length;i++){}\n要求3因为需要获取位置判断是否交替，单独一个增强循环无法实现要求\n要求2同理，标准循环控制索引初始、边界、增量可以实现3个需求", "answer": "01010", "content": "int [] array ={1, 2, 3,4,5};", "id": 144, "options": ["无法使用标准for循环实现要求2和3。", "可以使用标准for循环实现要求1,2和3。", "可以使用增强for循环实现要求1、2和3。", "可以使用增强for循环实现要求1。", "无法使用增强for循环或标准for循环实现要求3。"], "title": "假定要求如下：\n1.按输入顺序处理数组的所有元素。\n2.按输入的反向顺序处理数组的所有元素。\n3.按输入顺序交替处理数组的元素。\n\n哪两项描述是正确的? ", "type": 1}, {"analysis": "protected 访问修饰符允许子类访问和重写父类的方法。\n\n根据Java的访问修饰符规则，子类中重写的方法的访问修饰符不能比父类中被重写方法的访问修饰符更严格。\n\n而默认的修饰符是package-private，仅允许同包类访问，而protected除了同包类可访问，还可以让子类访问。所以revolve作为子类方法，需要修饰为protected或public才可通过编译", "answer": "00110", "content": "\nabstract class Planet {\n    protected void revolve() {     //line n1\n    }\n\n    abstract void rotate();       //line n2\n}\n\nclass Earth extends Planet {\n    void revolve() {               //line n3\n    }\n\n    protected void rotate() {        //line n4\n    }\n}\n", "id": 145, "options": ["将line n1处的方法设为public", "将line n2处的方法设为public", "将line n3处的方法设为public", "将line n3处的方法设为protected", "将line n4处的方法设为public"], "title": "单独进行哪两项修改可使该代码通过编译", "type": 1}, {"analysis": "static标识符的是静态变量，多个实例共享同一个内存，所以以最后一次修改为准。", "answer": "0010", "content": "public class X {\n    static int i;\n    int j;\n\n    public static void main(String[] args) {\n        X x1 = new X();\n        X x2 = new X();\n        x1.i = 3;\n        x1.j = 4;\n        x2.i = 5;\n        x2.j = 6;\n        System.out.println(\n                x1.i + \" \" +\n                x1.j + \" \" +\n                x2.i + \" \" +\n                x2.j);\n    }\n}", "id": 146, "options": ["3 4 3 6", "3 6 4 6", "5 4 5 6", "3 4 5 6"], "title": "结果是什么?", "type": 0}, {"analysis": "虽然同名变量优先访问局部变量，但是输出语句和定义局部变量的语句不在同一个作用域(定义在try catch语句块中),所以输出的是全局的字符串", "answer": "0010", "content": "public class App {\n    String myStr = \"7007\";\n\n    public void doStuff(String str){\n        int myNum = 0;\n        try {\n            String myStr =str;\n            myNum = Integer.parseInt(myStr);\n        }catch(NumberFormatException ne ){\n            System.err.println(\"Error\");\n        }\n        System.out.println(\n                \"myStr: \" + myStr + \", myNum: \" + myNum);\n    }\n\n    public static void main(String[] args){\n        App obj = new App();\n        obj.doStuff(\"9009\");\n    }\n}", "id": 147, "options": ["myStr:9009, myNum:9009", "myStr:7007, myNum:7007", "myStr:7007, myNum:9009", "编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "私有方法外部无法调用，只能通过反射或类似getter setter内部方法间接调用", "answer": "0100", "content": "class Caller{\n    private void init(){\n        System.out.println(\"Initialized\");\n    }\n\n    public void start(){\n        init();\n        System.out.println(\"Started\")\n    }\n}\npublic class TestCall{\n    public static void main(String[] args){\n        Caller c = new Caller();\n        c.start();\n        c.init();\n    }\n\n}", "id": 148, "options": ["Initialized\nStarted\nInitialized", "编译失败", "在运行时引发异常", "Initialized\nStarted"], "title": "结果是什么?", "type": 0}, {"analysis": "此处a++先返回值再运算，判断时先返回9再自加为10，输出时就为10...", "answer": "0100", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        \n        if (aVar++ < 10){\n            System.out.println(aVar + \"Hello World!\");\n        }else{\n            System.out.println(aVar + \"Hello Universe!\");\n        }\n\n    }\n}\n", "id": 149, "options": ["10 Hello Universe", "10 Hello World", "编译失败", "9 Hello World"], "title": "如果整数 aVar 为9，结果是什么?", "type": 0}, {"analysis": "正确的只有一个增强for和一个标准for循环，其它选项要么只输出索引，要么没有初始化值，要么错误的将增强for中的元素值作为索引", "answer": "100010", "content": "int[] intArr={8,16,32,64,128};", "id": 150, "options": ["for (int i : intArr) {\n    System.out.print(i + \"\");\n}", "for (int i : intArr) {\n    System.out.print(intArr[i] + \"\");\n}", "for (int i = 0; i < intArr.length; i++) {\n    System.out.print(i + \"\");\n}", "for (int i; i < intArr.length; i++) {\n    System.out.print(intArr[i] + \"\");\n}", "for (int i = 0; i < intArr.length; i++) {\n    System.out.print(intArr[i] + \"\");\n}", "for (int i : intArr) {\n    System.out.print(intArr[i] + \"\");\n    i++;\n}"], "title": "单独使用哪两个代码片段可输出此数组中的每个元素?", "type": 1}, {"analysis": "lambda表达式基本语法\n(parameter_list) -> { lambda_body }\n只传入参数名则编译器会自行推断参数的类型\n\nPredicate类常用于方法判断,通过泛型传入待判断参数的类型, 传入lambda表达式并返回布尔值 即可调用test方法借助表达式进行判断, 多个Predicate可以使用and、 or、 negate... 方法来组合\n\ncheckAge(iList , (Person p) -> p.getAge() > 40 );\n// 为参数声明类型需要在括号中\n\ncheckAge(iList , (Person p) -> { return p.getAge() > 40; } );\n定义返回方法体需要手动return返回\n\ncheckAge(iList , (p) ->  p.getAge() > 40 ); \n// 原本未传入参数 ", "answer": "0001", "content": "// Person.java\n\npublic class Person {\n    String name;\n    int age;\n\n    public Person(String n, int a) {\n        name = n;\n        age = a;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n// Test.java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class Test {\n\n    public static void checkAge(List<Person> list, Predicate<Person> predicate) {\n        for (Person p : list) {\n            if (predicate.test(p)) {\n                System.out.println(p.name + \" \");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Person> iList = Arrays.asList(new Person(\"Hank\", 45),\n                new Person(\"Charlie\", 40),\n                new Person(\"Smith\", 38));\n        // line n1\n    }\n    \n\n}\n", "id": 151, "options": ["checkAge(iList , (Person p)->{p.getAge() > 40;} );", "checkAge(iList , Person p -> p.getAge() > 40 );\t", "checkAge(iList , () -> p.getAge() > 40 );\t", "checkAge(iList , p -> p.getAge() > 40 );"], "title": "在line n1 处插入哪个代码片段可使该代码输出 Hank?", "type": 0}, {"analysis": "直接传引用覆盖了原本的nums1, 不需要在意原本数组的长度", "answer": "0001", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int nums1[] = new int[3];\n        int nums2[] = { 1, 2, 3, 4, 5 };\n        nums1 = nums2;\n        for (int x : nums1) {\n            System.out.print(x + \":\");\n        }\n    }\n\n}", "id": 152, "options": ["运行时引发ArrayOutOfBoundsException", "编译失败", "1:2:3:", "1:2:3:4:5:"], "title": "结果是什么?", "type": 0}, {"analysis": "D 选项直接把str1的引用传递过去，使str2也指向str1所以他们两个相等\n\nA 选项值得注意StringBuilder重写了toString方法, 从原本String 返回本身实例变成了新建一个本身的镜像 , 所以不是同一个地址判断仍然为false\n// return new String(value, 0, count);", "answer": "0001", "content": "public class Test {\n\n    public static void main(String[] args) {\n      \n        StringBuilder sb1 = new StringBuilder(\"Duke\");\n        String str1 = sb1.toString();\n      \n        // 插入代码片段\n      \n        System.out.print(str1 == str2);\n    }\n\n}", "id": 153, "options": ["String str2 = sb1.toString();", "String str2 = new String(str1);", "String str2 = \"Duke\";", "String str2 = str1;"], "title": "在第9行插入哪些代码片段可使该代码输出 true?", "type": 0}, {"analysis": "先输出数组再输出对象,因为没有重写toString方法所以直接输出地址\n最后再输出数组元素的对象成员值（基本类型int) C", "answer": "00100", "content": "public class Planet {\n\tpublic String name;\n\tpublic int moons;\n\t\n\tpublic Planet (String name,int moons){\n\t\tthis.name = name;\n\t\tthis.moons = moons;\n\t}\n\tpublic static void main(String[] args) {\n\t\tPlanet[] planets = {\n\t\t\tnew Planet(\"Mercury\",0),\n\t\t\tnew Planet(\"Venus\",0),\n\t\t\tnew Planet(\"Earth\",1),\n\t\t\tnew Planet(\"Mars\",2)\n\t\t};\n\t\tSystem.out.println(planets);\n\t\tSystem.out.println(planets[2]);\n\t\tSystem.out.println(planets[2].moons);\n\t}\n\n}", "id": 154, "options": ["planets\nEarth\n1", "[LPlanets.Plant;@15db9742\nEarth\n1", "[LPlanets.Plant;@15db9742\nPlanets.Plant;@6d06d69c\n1", "[LPlanets.Plant;@15db9742\nPlanets.Plant;@6d06d69c\n[LPlanets.Moon;@7852e922", "LPlanets.Plant;@15db9742\nVens\n0"], "title": "结果是什么?", "type": 0}, {"analysis": "选项 A 和 D 中的代码存在语法错误，而选项 B 中的嵌套条件运算符逻辑错误", "answer": "0010", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        String stuff = \"TV\";\n        String res = null;\n\n        if (stuff.equals(\"TV\")) {\n            res = \"Walter\";\n        } else if (stuff.equals(\"Movie\")) {\n            res = \"White\";\n        } else {\n            res = \"No Result\";\n        }\n\n    }\n\n}\n", "id": 155, "options": ["res = stuff.equals(\"TV\") ? \"Walter\" else stuff.equals(\"Movie\") ? \"White\" : \"No Result\";", "res = stuff.equals(\"TV\") ? stuff.equals(\"Movie\") ? \"Walter\" : \"White\" : \"No Result\";", "res = stuff.equals(\"TV\") ? \"Walter\" : stuff.equals(\"Movie\") ? \"White\" : \"No Result\";", "stuff.equals(\"TV\") ? res = \"Walter\" : stuff.equals(\"Movie\") ? res = \"White\" : res = \"No Result\";"], "title": "哪个代码片段可以替换if块?", "type": 0}, {"analysis": "字符长度为11, 而遍历范围为[0,12) 会访问超出字符长度导出抛出越界错误，然后被捕获输出 Out of limits, 最后才输出被转换过的大小写", "answer": "0010", "content": "public class TestTry {\n    public static void main(String[] args) {\n        StringBuilder message = new StringBuilder(\"hello java!\");\n        int pos = 0;\n        try {\n            for (pos = 0; pos < 12; pos++) {\n                switch (message.charAt(pos)) {\n                    case 'a':\n                    case 'e':\n                    case 'o':\n                        String uc = Character.toString(message.charAt(pos)).toUpperCase();\n                        message.replace(pos, pos + 1, uc);\n                }\n            }\n        } catch (Exception e) {\n            System.out.println(\"Out of limits\");\n        }\n        System.out.println(message);\n    }\n}", "id": 156, "options": ["hEllOjAvA!", "Hello java!", "Out of limits hEllOjAvA!", "Out of limits"], "title": "结果是什么?", "type": 0}, {"analysis": "初始值为null(不显示初始化时默认值也是null), 直接相加拼接会产生新字符串\n最后的结果为 nullJava\n所以直接equals判断值也仍然返回false", "answer": "0100", "content": "public class CharToStr {\n    public static void main(String[] args) {\n        String str1 = \"Java\";\n        char str2[] = { 'J', 'a', 'v', 'a' };\n        String str3 = null;\n        for (char c : str2) {\n            str3 = str3 + c;\n        }\n        if (str1.equals(str3))\n            System.out.print(\"Successful\");\n        else\n            System.out.print(\"Unsuccessful\");\n    }\n}", "id": 157, "options": ["Successful", "Unsuccessful", "编译失败", "运行时抛出异常"], "title": "结果是什么?", "type": 0}, {"analysis": "这里子类默认的空参构造函数会尝试调用父类空参函数，但父类定义了带有参数的构造函数，所以父类不会隐式的定义空参构造函数。\n需要在子类构造函数中添加super调用其余构造函数或在Sports类中显式定义空参构造函数\n\n而super调用父类方法和this调用类中其他的构造方法都需要位于构造函数第一行，所以一般不会同时调用这两个方法\n\n(B选项通过super调用父类成员变量是合法，但因为父类未拥有空参构造方法依然不可通过编译的)\n", "answer": "1000", "content": "class Sports {\n    int num_players;\n    String name, ground_condition;\n\n    Sports(int np, String sname, String sground) {\n        num_players = np;\n        name = sname;\n        ground_condition = sground;\n    }\n}\n\nclass Cricket extends Sports {\n    int num_umpires;\n    int num_substitutes;\n  \t// insert coed to here\n}\n", "id": 158, "options": ["Cricket() {\n  super(11, \"Cricket\", \"Condidtion OK\");\n  num_umpires = 3;\n  num_substitutes = 2;\n}", "Cricket() {\n  super.ground_condition = \"Condition OK\";\n  super.name = \"Cricket\";\n  super.num_players = 11;\n  num_umpires = 3;\n  num_substitutes = 2;\n}", "Cricket() {\n  this(3, 2);\n  super(11, \"Cricket\", \"Condidtion OK\");\n}\n\nCricket(int nu, int ns) {\n  this.num_umpires = nu;\n  this.num_substitutes = ns;\n}", "Cricket() {\n  this.num_umpires = 3;\n  this.num_substitutes = 2;\n  super(11, \"Cricket\", \"Condidtion OK\");\n}"], "title": "以下插入哪个代码片段能通过编译?", "type": 0}, {"analysis": "在 Java 中，局部变量（如此处 sum）在使用之前必须进行初始化。否则，在编译时会报错，因为编译器无法确定变量的初始值。\n", "answer": "00001", "content": "public class Calculator {\n    public static void main(String[] args) {\n        int num = 5;\n        int sum;\n\n        do {\n            sum += num;\n        } while ((num--) > 1);\n        System.out.println(\"The sum is\" + sum + \".\");\n    }\n}", "id": 159, "options": ["The sum is 2", "The sum is 14", "The sum is 15", "循环无限执行", "编译错误"], "title": "结果是什么?", "type": 0}, {"analysis": "这里说的是类声明 \"中\" , 显然引入语句和包名定义是在class外的", "answer": "0101", "content": "// 看选项", "id": 160, "options": ["import语句", "字段声明", "package语句", "方法声明"], "title": "在Java类声明中，哪两项可以合法地包含?", "type": 1}, {"analysis": "输出的是执行操作后返回的str，所以相应操作都能成功执行\nsubstirng忽略endIndex则直接从索引2截断到末尾 Ja[va]", "answer": "0100", "content": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Alpha {\n    public String doStuff(String msg) {\n        return msg;\n    }\n}\n\nclass Beta extends Alpha {\n    public String doStuff(String msg) {\n        return msg.replace('a', 'e');\n    }\n}\n\nclass Gamma extends Beta {\n    public String doStuff(String msg) {\n        return msg.substring(2);\n    }\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        List<Alpha> strs = new ArrayList<Alpha>();\n        strs.add(new Alpha());\n        strs.add(new Beta());\n        strs.add(new Gamma());\n        for (Alpha t : strs) {\n            System.out.println(t.doStuff(\"Java\"));\n        }\n    }\n\n}\n", "id": 161, "options": ["Java Java Java", "Java Jeve va", "Java Jeve ve", "Compilation fails"], "title": "结果是什么?", "type": 0}, {"analysis": "跳过小于2和输出后继续跳过循环，打断循环无法继续输出后续内容", "answer": "0001", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int [] array = {1,2,3,4,5};\n        for (int i: array) {\n            if ( i < 2) { keyword1;}\n            System.out.println(i);\n            if ( i == 3) { keyword2;}\n        }\n    }\n\n}\n", "id": 162, "options": ["continue, break", "break, break", "break, continue", "continue, continue"], "title": "在keyword1 和 keyword2 处分别替换为什么关键字可以输出 2345?", "type": 0}, {"analysis": "基本的三目运算符运用", "answer": "00100", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int x = 10;\n        if (x > 10) {\n            System.out.println(\">\");\n        } else if (x < 10) {\n            System.out.println(\"<\");\n        } else {\n            System.out.println(\"=\");\n        }\n    }\n\n}\n", "id": 163, "options": ["System.out.printLn(x>10?\">,\": \"<\":\"=\");", "System.out.println(x>10? \">\"?\"<\":\"=\");", "System.out.println(x>10?\">\":x<10?\"<\":\"=\");", "System.out.printLn(x>10?\">\"?\"<\"?\"=\");", "以上都不行"], "title": "选项中那段代码可以输出同样的内容?", "type": 0}, {"analysis": "只有第二个元素长度不足10，调用substring 的endIndex 大于字符长度 会抛出错误输出 out of limits,然后继续执行循环", "answer": "1000", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        String names[] = new String[3];\n        names[0] = \"Mary Brown\";\n        names[1] = \"Nancy Red\";\n        names[2] = \"Jseey Orange\";\n        try {\n            for (String n : names) {\n                try {\n                    String pwd = n.substring(0, 3) + n.substring(6, 10);\n                    System.out.println(pwd);\n                } catch (StringIndexOutOfBoundsException sie) {\n                    System.out.println(\"String out of limits\");\n                }\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Array out of limits\");\n        }\n    }\n\n}\n", "id": 164, "options": ["Marrown String out of limits JesOran", "Marrown String out of limits Array out of limits", "Marrown String out of limits", "Marrown NanRed JesOran"], "title": "结果是什么?", "type": 0}, {"analysis": "注意运行的过程中元素的值已经被改变了\n65 68 69 -> 65 68 65\n65 68 65 -> 68 68 65\n68 68 65 -> 68 65 65", "answer": "01000", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int iArray[] = { 65, 68, 69 };\n        iArray[2] = iArray[0];\n        iArray[0] = iArray[1];\n        iArray[1] = iArray[2];\n        for (int element : iArray) {\n            System.out.print(element + \" \");\n        }\n    }\n\n}\n", "id": 165, "options": ["68, 65, 69", "68, 65, 65", "65, 68, 65", " 65, 68, 69", "编译错误"], "title": "结果是什么?", "type": 0}, {"analysis": "全局变量并不像局部变量一样需要初始化后才能使用，for循环中的重名i是局部变量，里面的循环代码编译器会自动推断所用的i。所以就是循环了6次 (外部循环) 全局变量i默认值是0, 循环范围是[0, 6) ~ [0, 5]", "answer": "00010", "content": "public class Natural {\n    private int i;\n\n    void disp() {\n        while (i <= 5) {\n            for (int i = 1; i <= 5;) {\n                System.out.print(i + \" \");\n                i++;\n            }\n            i++;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Natural().disp();\n    }\n}", "id": 166, "options": ["打印1 2 3 4 5 一次", "打印 1 3 5 一次", "打印 1 2 3 4 5 五次", "打印1 2 3 4 5 六次", "编译错误"], "title": "结果是什么?", "type": 0}, {"analysis": "// 修改了一些选项以满足题库答案\n\n抽象类继承抽象类无需显式声明抽象方法，implements仅用于interface接口用于实现接口，不能用于抽象类\n\n非抽象类不能定义无方法体的方法\n", "answer": "010010", "content": "public abstract class Shape {\n    private int x;\n    private int y;\n\n    public abstract void draw();\n\n    public void setAnchor(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}", "id": 167, "options": ["public class Circle implements Shape {\n    private int radius;\n}", "public abstract class Circle extends Shape {\n    private int radius;\n}", "public class Circle extends Shape {\n    private int radius;\n\n    public void draw();\n}", "public abstract class Circle implements Shape {\n    private int radius;\n\n    public void draw();\n}", "public class Circle extends Shape {\n    private int radius;\n\n    public void draw() {\n        /* code here */\n    }\n}", "public abstract class Circle implements Shape {\n    private int radius;\n\n    public void draw() {\n        /* code here */\n    }\n}"], "title": "哪两个选项正确使用了Shape类?", "type": 1}, {"analysis": "注意数组下标范围为[0,数组长度-1]即可\n", "answer": "00100", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] intArr = { 15, 30, 45, 60, 75 };\n        intArr[2] = intArr[4];\n        intArr[4] = 90;     \n    }\n\n}\n", "id": 168, "options": ["15, 60, 45, 90, 75", "15, 90, 45, 90, 75", "15, 30, 75, 60, 90", "15, 30, 90, 60, 90", "15, 4, 45, 60, 90"], "title": "数组内容是什么?", "type": 0}, {"analysis": "方法执行时基本类型 整形是传值引用，对形式参数的修改不会影响到原本传入的数据。 而对象类型是传值引用，修改的是传入的对象的引用的成员变量的值。\n", "answer": "0010", "content": "\nclass Product {\n   double price;\n}\n\npublic class Test{\n   public void updatePrice(Product product,double price){\n      price=price*2;\n      product.price=product.price+price;\n   }\n   public static void main(String[] args){\n      Product prt=new Product();\n      prt.price=200;\n      double newPrice=100;\n      \n      Test t=new Test();\n      t.updatePrice(prt, newPrice);\n      System.out.println(prt.price +\" : \"+newPrice);\n   }\n}", "id": 169, "options": ["200.0 : 100.0", "400.0 : 200.0", "400.0 : 100.0", "编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "\n抽象类继承另一抽象类或实现接口时不需要显式声明继承或实现过来的方法", "answer": "01010", "content": "abstract class X {\n    public abstract void methodX();\n}\n\ninterface Y {\n    public void methodY();\n}\n", "id": 170, "options": ["class Z extends X implements Y {\n    public void methodZ() {\n    }\n}", "abstract class Z extends X implements Y {\n    public void methodZ() {\n    }\n}", "class Z extends X implements Y {\n    public void methodX() {\n    }\n}", "abstract class Z extends X implements Y {\n}", "class Z extends X implements Y {\n    public void methodY() {\n    }\n}"], "title": "哪两个代码片段是合法的?", "type": 1}, {"analysis": "字符拼接，不包裹在括号内的整数相加就会被连续拼接而不是等计算出结果再拼接", "answer": "0001", "content": "\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(\"5+2= \" + 3 + 4);\n        System.out.println(\"5+2=\" + (3 + 4));\n    }\n}", "id": 171, "options": ["5+2 =34\n5+2 =34", "5+2+3+4\n5+2=7", "7=7\n7+7", "5+2=34\n5+2=7"], "title": "结果是什么?", "type": 0}, {"analysis": "java接口可以多实现，但是不能继承多个类，事实上接口是java实现多继承的一种方式", "answer": "10001", "content": "class A{}\nclass B{}\ninterface X{}\ninterface Y{}", "id": 172, "options": ["class C extends A implements X { }", "class C implements Y extends B { }", "class C extends A, B { }", "class C implements X, Y extends B { }", "class C extends B implements X, Y { }"], "title": "哪两个关于C的定义语句是合法的?", "type": 1}, {"analysis": "for语句中的x是局部变量，作用域仅限于for语句块内。所以后面输出的语句无法访问到x，", "answer": "00010", "content": "public class Whizlabs {\n    public static void main(String[] args) {\n        int sum = 0;\n\n        for (int x = 0; x <= 10; x++)\n            sum += x;\n        System.out.print(\"Sum for 0 to\" + x);\n        System.out.println(\"=\" + sum);\n    }\n}", "id": 173, "options": ["Sum for 0 to 0 = 55", "Sum for 0 to 10 = 55", "代码在第六行编译错误", "代码在第七行编译错误", "一个异常在运行时抛出"], "title": "结果是什么?", "type": 0}, {"analysis": "substring方法返回操作后的结果，而不是直接在原字符串上操作\nappend方法可以选择插入字符的开始处和结束处，此处creditCard插入了1234-5678-9101-[1121] 满足条件", "answer": "0110", "content": "class CCMask {\n    public static String maskCC(String creditCard) {\n        String x = \"XXXX-XXXX-XXXX-\";\n        // line n1\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maskCC(\"1234-5678-9101-1121\"));\n    }\n}", "id": 174, "options": ["StringBuilder sb = new StringBuilder(creditCard); \nsb.substring(15,19); \nreturn x + sb;", "return x + creditCard.substring(15,19);", "StringBuilder sb = new StringBuilder(x); \nsb.append(creditCard,15,19); \nreturn sb.toString();", "StringBuilder sb =new StringBuilder(creditCard); \nStringBuilder s = sb.insert(0,x); \nreturn s.toString();"], "title": "现在正在开发一个银行模块，且已经开发了一个名为 CCMask 的类，该类具有 maskcc 方法。\n\n必须确保 maskcc 方法返回一个字符串，该字符串隐藏除最后四位数字(以及分隔每组四位数字的连字符)之外的所有信用卡号。\n\n为了达到这个要求，应该在第 n1行使用哪两个代码片段？", "type": 1}, {"analysis": "直接定义数组长度，因为重新赋值长度不满足预先定义条件会出现数组越界错误。 而C选项没有将值设置回去\n\nD选项则是错误使用了增强for 会出现编译错误", "answer": "1000", "content": "public class Test {\n\n    public static void main(String[] args) {\n        String[][] arra = new String[3][];\n        arra[0] = new String[] { \"rose\", \"lily\" };\n        arra[1] = new String[] { \"apple\", \"berry\", \"cherry\", \"grapes\" };\n        arra[2] = new String[] { \"beans\", \"carrot\", \"potato\" };\n\n        // insert code fragment here\n    }\n}", "id": 175, "options": ["for (int i = 0; i < arra.length; i++) {\n  for (int j = 0; j < arra[i].length; j++) {\n    arra[i][j] = arra[i][j].toUpperCase();\n  }\n}", "for (int i = 0; i < 3; i++) {\n  for (int j = 0; j < 4; j++) {\n    arra[i][j] = arra[i][j].toUpperCase();\n  }\n}\n", "for (String a[] : arra) {\n  for (String x : a) {\n    x.toUpperCase();\n  }\n}", "for (int i : arra.length) {\n  for (String x : arra) {\n    arra[i].toUpperCase();\n  }\n}"], "title": "哪个代码片段使代码能够成功地将 arra 元素更改为大写？", "type": 0}, {"analysis": "在Java 8之前，接口中只允许定义抽象方法，需要在实现类中对接口的所有方法进行具体实现。然而，自Java 8开始，引入了默认方法（default method）的概念，使得接口可以拥有具有默认实现的方法。\n\n注意\n1.默认方法可以在使用而不需要强制重写\n2.如果一个类实现了多个接口，而这些接口中存在相同的默认方法，那么实现类必须重写该方法来消除冲突。\n3.默认方法可以调用接口中的其他默认方法。", "answer": "00100", "content": "interface CanFly {\n    String tyoe = \"A\";\n\n    void fly();\n\n    /* blank */ String getType(){\n\t\treturn type;\n\t}\n\n}", "id": 176, "options": ["abstract", "public", "default", "它不会用任何接口编译，因为接口不能有非抽象方法。", "它不需要替换注释处就可以编译。"], "title": "下列哪一项替换blank处注释，使其编译成功?", "type": 0}, {"analysis": "break, continue 语句只能用于循环语句，条件语句中使用会导致编译失败", "answer": "00001", "content": "\npublic class Test {\n    int sum = 0;\n\n    public void doCheck(int number){\n        if (number %2 == 0){\n            break;\n        }else{\n            for (int i = 0; i < number;i++){\n                sum += i;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Test obj = new Test();\n        System.out.println(\"Red\" + obj.sum);\n        obj.doCheck(2);\n    }\n\n}", "id": 177, "options": ["Red 0 Orange 0 Green 3", "Red 0\nOrange 0\nGreen 6", "Red 0 Orange 1", "Green 4", "编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "编译错误，while语句中应该为返回布尔值的表达式", "answer": "01000", "content": "public class MyClass {\n\n    public static void main(String[] args) {\n        while (int ii = 0; ii < 2) {\n            ii++;\n            System.out.println(\"ii = \" + ii);\n        }\n    }\n\n}", "id": 178, "options": ["ii = 1 ii = 2", "编译失败", "程序什么都不打印", "程序无限循环没有输出", "程序无限输出\nii = 1\nii = 1"], "title": "结果是什么?", "type": 0}, {"analysis": "注意细节，循环语句块最后一句是break打断循环，即输出A之后就停止循环继续输出Work done了", "answer": "0010", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        String[] arr = { \"A\", \"B\", \"C\", \"D\" };\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n            if (arr[i].equals(\"C\")) {\n                continue;\n            }\n            System.out.println(\"Work done\");\n            break;\n        }\n    }\n\n}", "id": 179, "options": ["A B C Work done", "A B C D Work done", "A Work done", "编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "// 靠积累了\n非检查异常指的是程序中不需要显示捕获的异常，往往是执行时才会抛出的异常。\n以下举出上面包括的非检查异常\nAssertionErr 通常用于表示程序中的错误或断言失败，无法在编译时判断和处理。\nArithmeticExp 算数错误引发的异常，如除以0\n\nIndexOutOfBoundExp 数组越界异常\n\nFileNotFoundExp IOExp的子类，表示找不到打开的指定文件\n\nIllegalArgExp 传递的方法参数不合预期或无效\n\nNumberFormatExp 表示转换字符串为数字时字符串格式不正确\n\nIOErr IOExp的子类，表示由I/O(读写)操作失败引发的异常(通常在执行中发生。特别的是，IOExp为了确保程序稳定可靠，是检查异常需要显式处理或声明)\n\n# 断言assert\n断言用于在代码中指定一个布尔条件，如果该条件不满足，则抛出一个AssertionError异常。\n\n断言语法的一般形式如下：\n\nassert booleanExpression;\n\n默认情况下，Java虚拟机会禁用断言。要启用断言，可以使用命令行参数-ea或-enableassertions。\n\n例：\njava -ea clzName\n", "answer": "10000", "content": "// 插入代码", "id": 180, "options": ["AssertionError,\nArrayIndexOutOfBoundsException,\nArithmeticException", "AssertionError, IOError, IOException", "ArithmeticException,\nFileNotFoundException,\nNumberFormatException", "FileNotFoundException,\nIOException,\nSQLException", "ArrayIndexOutOfBoundException,\nIllegalArgumentException,\nFileNotFoundException"], "title": "给定下面类\n*\tAssertionError\n*\tArithmeticException\n*\tArrayIndexOutofBoundsException\n*\tFileNotFoundException\n*\tIllegalArgumentException\n*\tIOError\n*\tIOException\n*\tNumberFormatException\n*\tSQLException\n哪个选项中的所有类都属于非检查异常?", "type": 0}, {"analysis": "注意此处布尔值是包装类(基本类型的对象包装)，默认初始化值应该为null", "answer": "01000", "content": "public class Whizlabs {\n    private String name;\n    private Boolean pass;\n\n    public static void main(String[] args) {\n        Whizlabs wb = new Whizlabs();\n        System.out.print(\"name=\" + wb.name);\n        System.out.print(\",pass =\" + wb.pass);\n    }\n}", "id": 181, "options": ["name =, pass =", "name = null, pass = null", "name = null, pass = false", "name = null pass = true", "编译出错"], "title": "结果是什么?", "type": 0}, {"analysis": "浮点类型相加，此处变量定义在没有强制转换的情况下应该选择同类型的float或精度更高的double双精度浮点类型\n(顺带一提，byte是整形，范围(-128 ~ 127)", "answer": "01010", "content": "\npublic class Test {\n    public static void main(String[] args) {\n        float i =4;\n        float j =2;\n        ____z=i+j;\n    }\n\n}", "id": 182, "options": ["long", "double", "int", "float", "byte"], "title": "在下划线处替换哪两个代码片段能通过编译?", "type": 1}, {"analysis": "A.对象不能被重用。 - 这个描述是错误的。在Java中，对象是可以被重用的。可以创建多个对象并在不同的地方使用它们。\n\nD.一个包必须包含多个类。 - 这个描述也是错误的。一个包可以包含一个或多个类，但并不是必须包含多个类。一个包可以只包含一个类。\n\nF.主方法必须在每个类中声明。 - 这个描述也是错误的。在Java中，主方法只需要在一个类中声明，这个类是程序的入口点。其他类可以没有主方法。\n\n对象可以共享行为意味着多个对象可以使用相同的方法或函数来执行相同的操作。\n即多个类的实例对象可以共享同一个方法", "answer": "011010", "content": "// 看选项", "id": 183, "options": ["对象不能被重用", "子类可以从超类(父类)继承", "对象可以与其他对象共享行为", "一个包必须包含多个类", "Object是所有其他对象的根类", "主方法必须在每个类中声明"], "title": "哪三个语句描述了Java语言的面向对象特性?", "type": 1}, {"analysis": "// 原题无法通过编译，修改了doChange第二次调用的传参和答案\n\n数组和对象都是引用传递，即方法中传递的是原变量的引用，修改形式参数的值会改变原参数的值", "answer": "0100", "content": "public class Test {\n    public static void doChange(int[] arr) {\n        for (int pos = 0; pos < arr.length; pos++) {\n            arr[pos] = arr[pos] + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 10, 20, 30 };\n        doChange(arr);\n        for (int x : arr) {\n            System.out.print(x + \", \");\n        }\n        doChange(arr);\n        System.out.print(arr[0] + \",\" + arr[1] + \",\" + arr[2]);\n    }\n\n}", "id": 184, "options": ["11, 21, 31, 11, 21, 31", "11, 21, 31, 12, 22, 32", "12, 22, 32, 12, 22, 32", "10, 20, 30, 10, 20, 30"], "title": "结果是什么?", "type": 0}, {"analysis": "该代码编译失败的原因是List在泛型中应传入对象(如int包装类Integer)而不是基本类型 int，因为泛型类型参数必须是引用类型。\n\nremoveIf，是在 Java 8 中添加到 java.util.List 接口中的一个默认方法。该方法接受一个 Predicate（谓词）作为参数，用于指定移除元素的条件。\nPredicate 常用于测试判断，传入lambda返回布尔值，定义实例可以利用test()方法判断是否满足表达式，直接传lambda则默认调用表达式返回值\n\n举例:\nPredicate<Integer> predicate = e -> e % 2 != 0;\nlist.removeIf(predicate);\n// true\nSystem.out.println(predicate.test(11));\n// [30]\nSystem.out.println(list);", "answer": "00010", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Whizlabs {\n\n    public static void main(String[] args){\n\t\tList<int> list=new ArrayList<>();\n\t\tlist.add(21); \n        list.add(13);\n        list.add(30);\n        list.add(11);\n        list.removeIf(e -> e % 2 != 0);\n\t\tSystem.out.println(list);\n\t}\n}", "id": 185, "options": ["[21, 13, 11]", "[30]", "[]", "代码在第7行编译失败", "代码在第10行编译失败"], "title": "结果是什么?", "type": 0}, {"analysis": "子类继承父类时，子类的构造方法需要显式调用父类的构造方法。\n\n一般情况下子类会隐式地调用父类的默认（无参）构造方法，以确保父类的初始化。\n\n如果父类没有提供默认构造方法，并且只提供了带参数的构造方法，那么子类的构造方法必须显式调用父类的构造方法，并传入适当的参数。", "answer": "0010", "content": "class CD {\n    int r;\n\n    CD(int r) {\n        this.r = r;\n    }\n}\n\nclass DVD extends CD {\n    int c;\n\n    DVD(int r, int c) {\n        // line n1\n    }\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        DVD dvd = new DVD(10,20);\n    }\n\n}", "id": 186, "options": ["super.r=r;\nthis.c=c;", "super(r);\nthis(c);", "super(r);\nthis.c=c;", "this.c=r;\nsuper(c);"], "title": "在n1处插入哪个选项能使代码通过编译?", "type": 0}, {"analysis": "Java 中，数组的声明有两种常见的方式：\n\n\nClike风格：Object a[], b[] = new Object[3];\nJava特有的：Object[] a, b = new Object[3];\n\n这两种风格基本上是等价的(都只初始化了b数组)", "answer": "1010", "content": "// 看选项", "id": 187, "options": ["Object array[];", "Boolean array[3];", "int[] array;", "Float[2] array;"], "title": "哪两个选项是合法的声明?", "type": 1}, {"analysis": "不同包引入类需要import 类所在的全部包(*) 或单独引入类(import sales.SalesMan) ", "answer": "00001", "content": "// SalesMan.java\npackage sales;\n\npublic class SalesMan {\n}\n\n// Product.java\npackage sales.products;\n\npublic class Product {\n}\n\n\n// USMarket.java\npackage market;\n\n// line n1\n\t\t\npublic class USMarket {\n    SalesMan sm;\n    Product p;\n}\n", "id": 188, "options": ["import sales.*;", "import java.sales.products.*;", "import sales;\nimport sales.products;", "import sales.*;\nimport products.*;", "import sales.*;\nimport sales.products.*;"], "title": "在n1处替换哪个选项能通过编译?", "type": 0}, {"analysis": "获取命令行第三个参数(104) ，大于100 抛出自定义异常, try_catch 中又输出了异常的类名", "answer": "00100", "content": "\nclass MarksOutOfBoundsException extends IndexOutOfBoundsException {\n}\npublic class GradingProcess {\n\n    void verify(int marks) throws IndexOutOfBoundsException {\n        if (marks > 100) {\n            throw new MarksOutOfBoundsException();\n\n        }\n\n        if (marks > 50) {\n            System.out.print(\"Pass\");\n        } else {\n            System.out.print(\"Fail\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int marks = Integer.parseInt(args[2]);\n        try {\n            new GradingProcess().verify(marks);\n\n        } catch (Exception e) {\n\n\n            System.out.print(e.getClass());\n\n        }\n\n    }\n\n}\n\n", "id": 189, "options": ["Pass", "Fail", "class MarketOutOfBoundsException", "class IndexOutOfBoundsException", "class Exception"], "title": "在命令行中输入 java GradingProcess 89 50 104 执行后的结果是什么?", "type": 0}, {"analysis": "obj3是sun的实例obj2的引用拷贝，实际上三个类型强转后仍然调用的是sun实例的方法\n\n在Java中，向上转型是安全的，可以将一个子类的实例赋值给其父类的引用。因为子类继承了父类的方法和属性，所以通过父类的引用也可以调用子类的方法，但是底层执行的仍然是子类重写的方法。", "answer": "1000", "content": "class Star {\n    public void dostuff() {\n        System.out.println(\"Twinkling star\");\n    }\n}\n\ninterface Universe {\n    public void dostuff();\n}\n\nclass Sun extends Star implements Universe {\n    public void dostuff() {\n        System.out.println(\"Shining sun\");\n    }\n}\n\npublic class Bob {\n    public static void main(String[] args) {\n        Sun obj2 = new Sun();\n        Star obj3 = obj2;\n        ((Sun) obj3).dostuff();\n        ((Star) obj2).dostuff();\n        ((Universe) obj2).dostuff();\n    }\n}\n", "id": 190, "options": ["Shining Sun \nShining Sun\nShining Sun", "Shining Sun\nTwinkling Star\nShining Sun", "编译失败", "ClassCastException在执行中被抛出"], "title": "结果是什么?", "type": 0}, {"analysis": "直接赋值对象不会修改相应的引用，这里只有效执行了两个自增操作\n\n传递的是引用的副本，而不是原始引用本身。在doubling方法内部修改了ref的值时，只是修改了方法内部副本的值，并没有对原始的iObj引用进行修改。", "answer": "10000", "content": "public class Test {\n\n    static void doubling(Integer ref, int pv) {\n        ref = 20;\n        pv = 20;\n\n    }\n\n    public static void main(String[] args) {\n        Integer iObj = new Integer(10);\n        int iVar = 10;\n        doubling(iObj++, iVar++);\n        System.out.println(iObj + \", \" + iVar);\n    }\n\n}\n", "id": 191, "options": ["11, 11", "10, 10", "21, 11", "20, 20", "11, 12"], "title": "结果是什么?", "type": 0}, {"analysis": "String默认初始值为null， 相应的类型数组中未设置值为初始化值", "answer": "0100", "content": "public class Test {\n\n    public static void main(String[] args) {\n        try {\n            String[] arr = new String[4];\n            arr[1] = \"Unix\";\n            arr[2] = \"Linux\";\n            arr[3] = \"Solarios\";\n            for (String var : arr) {\n                System.out.print(var + \" \");\n\n            }\n\n        } catch (Exception e) {\n            System.out.print(e.getClass());\n        }\n\n    }\n\n}\n", "id": 192, "options": ["Unix Linux Solaris", "null Unix Linux Solaris", "class java.lang.Exception", "class java.lang.NullPointerException"], "title": "结果是什么?", "type": 0}, {"analysis": "此处索引为数组长度，触发越界错误", "answer": "0010", "content": "class SpecialException extends Exception{\n    public SpecialException(String message){\n        super(message);\n        System.out.println(message);\n    }\n}\npublic class ExceotionTest {\n    public static void main(String[] args) {\n        try {\n            doSomething();\n        }\n        catch (SpecialException e){\n            System.out.println(e);\n        }\n    }\n    static void doSomething() throws SpecialException {\n        int[] ages = new int[4];\n        ages[4] = 17;\n        doSomethingElse();\n    }\n\n    static void doSomethingElse() throws SpecialException {\n        throw new SpecialException(\"Thrown at the end of doSomething method\");\n    }\n}", "id": 193, "options": ["在doSomething()方法结束时抛出SpecialException", "在主线程中发生了java.lang.ArrayIndexOutOfBoundsException错误", "在第13行抛出ArrayIndexOutOfBoundException", "在第16行抛出SpecialException"], "title": "结果是什么?", "type": 0}]}